{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _EthersAdapter_ethers, _EthersAdapter_signer, _EthersAdapter_provider;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\n\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\n\nconst safe_core_sdk_utils_1 = require(\"@safe-global/safe-core-sdk-utils\");\n\nconst contractInstancesEthers_1 = require(\"./contracts/contractInstancesEthers\");\n\nconst utils_1 = require(\"./utils\");\n\nclass EthersAdapter {\n  constructor(_ref) {\n    let {\n      ethers,\n      signerOrProvider\n    } = _ref;\n\n    _EthersAdapter_ethers.set(this, void 0);\n\n    _EthersAdapter_signer.set(this, void 0);\n\n    _EthersAdapter_provider.set(this, void 0);\n\n    if (!ethers) {\n      throw new Error('ethers property missing from options');\n    }\n\n    __classPrivateFieldSet(this, _EthersAdapter_ethers, ethers, \"f\");\n\n    const isSigner = signerOrProvider instanceof abstract_signer_1.Signer;\n\n    if (isSigner) {\n      const signer = signerOrProvider;\n\n      if (!signer.provider) {\n        throw new Error('Signer must be connected to a provider');\n      }\n\n      __classPrivateFieldSet(this, _EthersAdapter_provider, signer.provider, \"f\");\n\n      __classPrivateFieldSet(this, _EthersAdapter_signer, signer, \"f\");\n    } else {\n      __classPrivateFieldSet(this, _EthersAdapter_provider, signerOrProvider, \"f\");\n    }\n  }\n\n  getProvider() {\n    return __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n  }\n\n  getSigner() {\n    return __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\");\n  }\n\n  isAddress(address) {\n    return __classPrivateFieldGet(this, _EthersAdapter_ethers, \"f\").utils.isAddress(address);\n  }\n\n  async getEip3770Address(fullAddress) {\n    const chainId = await this.getChainId();\n    return (0, safe_core_sdk_utils_1.validateEip3770Address)(fullAddress, chainId);\n  }\n\n  async getBalance(address, blockTag) {\n    return bignumber_1.BigNumber.from(await __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getBalance(address, blockTag));\n  }\n\n  async getNonce(address, blockTag) {\n    return __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getTransactionCount(address, blockTag);\n  }\n\n  async getChainId() {\n    return (await __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getNetwork()).chainId;\n  }\n\n  getChecksummedAddress(address) {\n    return __classPrivateFieldGet(this, _EthersAdapter_ethers, \"f\").utils.getAddress(address);\n  }\n\n  getSafeContract(_ref2) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref2;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid SafeProxy contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getSafeContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  getSafeProxyFactoryContract(_ref3) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref3;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid SafeProxyFactory contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getSafeProxyFactoryContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  getMultiSendContract(_ref4) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref4;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid MultiSend contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getMultiSendContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  getMultiSendCallOnlyContract(_ref5) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref5;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid MultiSendCallOnly contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getMultiSendCallOnlyContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  getCompatibilityFallbackHandlerContract(_ref6) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref6;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid CompatibilityFallbackHandler contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getCompatibilityFallbackHandlerContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  getSignMessageLibContract(_ref7) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref7;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid SignMessageLib contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getSignMessageLibContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  getCreateCallContract(_ref8) {\n    let {\n      safeVersion,\n      chainId,\n      singletonDeployment,\n      customContractAddress\n    } = _ref8;\n    const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];\n\n    if (!contractAddress) {\n      throw new Error('Invalid CreateCall contract address');\n    }\n\n    const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\") || __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\");\n\n    return (0, contractInstancesEthers_1.getCreateCallContractInstance)(safeVersion, contractAddress, signerOrProvider);\n  }\n\n  async getContractCode(address, blockTag) {\n    return __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getCode(address, blockTag);\n  }\n\n  async isContractDeployed(address, blockTag) {\n    const contractCode = await __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getCode(address, blockTag);\n    return contractCode !== '0x';\n  }\n\n  async getStorageAt(address, position) {\n    const content = await __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getStorageAt(address, position);\n    const decodedContent = this.decodeParameters(['address'], content);\n    return decodedContent[0];\n  }\n\n  async getTransaction(transactionHash) {\n    return __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").getTransaction(transactionHash);\n  }\n\n  async getSignerAddress() {\n    var _a;\n\n    return (_a = __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\")) === null || _a === void 0 ? void 0 : _a.getAddress();\n  }\n\n  signMessage(message) {\n    if (!__classPrivateFieldGet(this, _EthersAdapter_signer, \"f\")) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    const messageArray = __classPrivateFieldGet(this, _EthersAdapter_ethers, \"f\").utils.arrayify(message);\n\n    return __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\").signMessage(messageArray);\n  }\n\n  async signTypedData(safeTransactionEIP712Args) {\n    if (!__classPrivateFieldGet(this, _EthersAdapter_signer, \"f\")) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    if ((0, utils_1.isTypedDataSigner)(__classPrivateFieldGet(this, _EthersAdapter_signer, \"f\"))) {\n      const typedData = (0, safe_core_sdk_utils_1.generateTypedData)(safeTransactionEIP712Args);\n      const signature = await __classPrivateFieldGet(this, _EthersAdapter_signer, \"f\")._signTypedData(typedData.domain, {\n        SafeTx: typedData.types.SafeTx\n      }, typedData.message);\n      return signature;\n    }\n\n    throw new Error('The current signer does not implement EIP-712 to sign typed data');\n  }\n\n  async estimateGas(transaction) {\n    return (await __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").estimateGas(transaction)).toNumber();\n  }\n\n  call(transaction, blockTag) {\n    return __classPrivateFieldGet(this, _EthersAdapter_provider, \"f\").call(transaction, blockTag);\n  }\n\n  encodeParameters(types, values) {\n    return new (__classPrivateFieldGet(this, _EthersAdapter_ethers, \"f\").utils.AbiCoder)().encode(types, values);\n  }\n\n  decodeParameters(types, values) {\n    return new (__classPrivateFieldGet(this, _EthersAdapter_ethers, \"f\").utils.AbiCoder)().decode(types, values);\n  }\n\n}\n\n_EthersAdapter_ethers = new WeakMap(), _EthersAdapter_signer = new WeakMap(), _EthersAdapter_provider = new WeakMap();\nexports.default = EthersAdapter; //# sourceMappingURL=EthersAdapter.js.map","map":null,"metadata":{},"sourceType":"script"}