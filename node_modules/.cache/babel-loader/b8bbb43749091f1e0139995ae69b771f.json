{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-9d546189.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-eea39a9a.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { C as Connector, U as UserRejectedRequestError, S as SwitchChainError } from '../../../../dist/errors-e1a2656b.browser.esm.js';\nimport '../../../../dist/checkPrivateRedeclaration-3aaaa21d.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nconst NAMESPACE = \"eip155\";\nconst REQUESTED_CHAINS_KEY = \"wagmi.requestedChains\";\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nconst LAST_USED_CHAIN_ID = \"last-used-chain-id\";\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _initProviderPromise = /*#__PURE__*/new WeakMap();\n\nvar _storage = /*#__PURE__*/new WeakMap();\n\nvar _createProvider = /*#__PURE__*/new WeakSet();\n\nvar _initProvider = /*#__PURE__*/new WeakSet();\n\nvar _isChainsStale = /*#__PURE__*/new WeakSet();\n\nvar _removeListeners = /*#__PURE__*/new WeakSet();\n\nvar _setRequestedChainsIds = /*#__PURE__*/new WeakSet();\n\nvar _getRequestedChainsIds = /*#__PURE__*/new WeakSet();\n\nvar _getNamespaceChainsIds = /*#__PURE__*/new WeakSet();\n\nvar _getNamespaceMethods = /*#__PURE__*/new WeakSet();\n\nclass WalletConnectConnector extends Connector {\n  constructor(config) {\n    super({ ...config,\n      options: {\n        isNewChainsStale: true,\n        ...config.options\n      }\n    });\n\n    _classPrivateMethodInitSpec(this, _getNamespaceMethods);\n\n    _classPrivateMethodInitSpec(this, _getNamespaceChainsIds);\n\n    _classPrivateMethodInitSpec(this, _getRequestedChainsIds);\n\n    _classPrivateMethodInitSpec(this, _setRequestedChainsIds);\n\n    _classPrivateMethodInitSpec(this, _removeListeners);\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     *\n     * There are exceptions however:\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n     *    then the chain is not considered stale.\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n     *    not considered stale.\n     *\n     * For the above cases, chain validation occurs dynamically when the user\n     * attempts to switch chain.\n     *\n     * Also check that dapp supports at least 1 chain from previously approved session.\n     */\n\n\n    _classPrivateMethodInitSpec(this, _isChainsStale);\n\n    _classPrivateMethodInitSpec(this, _initProvider);\n\n    _classPrivateMethodInitSpec(this, _createProvider);\n\n    _defineProperty(this, \"id\", \"walletConnect\");\n\n    _defineProperty(this, \"name\", \"WalletConnect\");\n\n    _defineProperty(this, \"ready\", true);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _initProviderPromise, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _storage, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = Number(chainId);\n      const unsupported = this.isChainUnsupported(id);\n\n      _classPrivateFieldGet(this, _storage).setItem(LAST_USED_CHAIN_ID, String(chainId));\n\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", () => {\n      _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\n\n      _classPrivateFieldGet(this, _storage).removeItem(LAST_USED_CHAIN_ID);\n\n      this.emit(\"disconnect\");\n    });\n\n    _defineProperty(this, \"onDisplayUri\", uri => {\n      this.emit(\"message\", {\n        type: \"display_uri\",\n        data: uri\n      });\n    });\n\n    _defineProperty(this, \"onConnect\", () => {\n      this.emit(\"connect\", {\n        provider: _classPrivateFieldGet(this, _provider)\n      });\n    });\n\n    _classPrivateFieldSet(this, _storage, config.options.storage);\n\n    _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\n  }\n\n  async connect() {\n    let {\n      chainId: chainIdP,\n      pairingTopic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      let targetChainId = chainIdP;\n\n      if (!targetChainId) {\n        const lastUsedChainIdStr = await _classPrivateFieldGet(this, _storage).getItem(LAST_USED_CHAIN_ID);\n        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;\n\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {\n          targetChainId = lastUsedChainId;\n        } else {\n          targetChainId = this.chains[0]?.chainId;\n        }\n      }\n\n      if (!targetChainId) {\n        throw new Error(\"No chains found on connector.\");\n      }\n\n      const provider = await this.getProvider();\n      this.setupListeners();\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this); // If there is an active session with stale chains, disconnect the current session.\n\n      if (provider.session && isChainsStale) {\n        await provider.disconnect();\n      } // If there no active session, or the chains are stale, connect.\n\n\n      if (!provider.session || isChainsStale) {\n        const optionalChains = this.chains.filter(chain => chain.chainId !== targetChainId).map(optionalChain => optionalChain.chainId);\n        this.emit(\"message\", {\n          type: \"connecting\"\n        });\n        await provider.connect({\n          pairingTopic,\n          chains: [targetChainId],\n          optionalChains: optionalChains.length > 0 ? optionalChains : [targetChainId]\n        });\n\n        _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, this.chains.map(_ref => {\n          let {\n            chainId\n          } = _ref;\n          return chainId;\n        }));\n      } // If session exists and chains are authorized, enable provider for required chain\n\n\n      const accounts = await provider.enable();\n\n      if (accounts.length === 0) {\n        throw new Error(\"No accounts found on provider.\");\n      }\n\n      const account = utils.getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user rejected/i.test(error?.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    const provider = await this.getProvider();\n\n    try {\n      await provider.disconnect();\n    } catch (error) {\n      if (!/No matching key/i.test(error.message)) {\n        throw error;\n      }\n    } finally {\n      _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n\n      _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, []);\n    }\n  }\n\n  async getAccount() {\n    const {\n      accounts\n    } = await this.getProvider();\n\n    if (accounts.length === 0) {\n      throw new Error(\"No accounts found on provider.\");\n    }\n\n    return utils.getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const {\n      chainId\n    } = await this.getProvider();\n    return chainId;\n  }\n\n  async getProvider() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!_classPrivateFieldGet(this, _provider)) {\n      await _classPrivateMethodGet(this, _createProvider, _createProvider2).call(this);\n    }\n\n    if (chainId) {\n      await this.switchChain(chainId);\n    }\n\n    if (!_classPrivateFieldGet(this, _provider)) {\n      throw new Error(\"No provider found.\");\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);\n      const isChainsStale = await _classPrivateMethodGet(this, _isChainsStale, _isChainsStale2).call(this); // If an account does not exist on the session, then the connector is unauthorized.\n\n      if (!account) {\n        return false;\n      } // If the chains are stale on the session, then the connector is unauthorized.\n\n\n      if (isChainsStale && provider.session) {\n        try {\n          await provider.disconnect();\n        } catch {} // eslint-disable-line no-empty\n\n\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async switchChain(chainId) {\n    const chain = this.chains.find(chain_ => chain_.chainId === chainId);\n\n    if (!chain) {\n      throw new SwitchChainError(new Error(\"chain not found on connector.\"));\n    }\n\n    try {\n      const provider = await this.getProvider();\n\n      const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\n\n      const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\n\n      const isChainApproved = namespaceChains.includes(chainId);\n\n      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n        await provider.request({\n          method: ADD_ETH_CHAIN_METHOD,\n          params: [{\n            chainId: utils.hexValue(chain.chainId),\n            blockExplorerUrls: [chain.explorers?.length ? chain.explorers[0] : undefined],\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: [...chain.rpc]\n          }]\n        });\n        const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\n        requestedChains.push(chainId);\n\n        _classPrivateMethodGet(this, _setRequestedChainsIds, _setRequestedChainsIds2).call(this, requestedChains);\n      }\n\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: utils.hexValue(chainId)\n        }]\n      });\n      return chain;\n    } catch (error) {\n      const message = typeof error === \"string\" ? error : error?.message;\n\n      if (/user rejected request/i.test(message)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      throw new SwitchChainError(error);\n    }\n  }\n\n  async setupListeners() {\n    if (!_classPrivateFieldGet(this, _provider)) {\n      return;\n    }\n\n    _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n\n    _classPrivateFieldGet(this, _provider).on(\"accountsChanged\", this.onAccountsChanged);\n\n    _classPrivateFieldGet(this, _provider).on(\"chainChanged\", this.onChainChanged);\n\n    _classPrivateFieldGet(this, _provider).on(\"disconnect\", this.onDisconnect);\n\n    _classPrivateFieldGet(this, _provider).on(\"session_delete\", this.onDisconnect);\n\n    _classPrivateFieldGet(this, _provider).on(\"display_uri\", this.onDisplayUri);\n\n    _classPrivateFieldGet(this, _provider).on(\"connect\", this.onConnect);\n  }\n\n}\n\nasync function _createProvider2() {\n  if (!_classPrivateFieldGet(this, _initProviderPromise) && \"object\" !== \"undefined\") {\n    _classPrivateFieldSet(this, _initProviderPromise, _classPrivateMethodGet(this, _initProvider, _initProvider2).call(this));\n  }\n\n  return _classPrivateFieldGet(this, _initProviderPromise);\n}\n\nasync function _initProvider2() {\n  const {\n    default: EthereumProvider,\n    OPTIONAL_EVENTS,\n    OPTIONAL_METHODS\n  } = await import('@walletconnect/ethereum-provider');\n  const [defaultChain, ...optionalChains] = this.chains.map(_ref2 => {\n    let {\n      chainId\n    } = _ref2;\n    return chainId;\n  });\n\n  if (defaultChain) {\n    // EthereumProvider populates & deduplicates required methods and events internally\n    _classPrivateFieldSet(this, _provider, await EthereumProvider.init({\n      showQrModal: this.options.qrcode !== false,\n      projectId: this.options.projectId,\n      optionalMethods: OPTIONAL_METHODS,\n      optionalEvents: OPTIONAL_EVENTS,\n      chains: [defaultChain],\n      optionalChains: optionalChains,\n      metadata: {\n        name: this.options.dappMetadata.name,\n        description: this.options.dappMetadata.description || \"\",\n        url: this.options.dappMetadata.url,\n        icons: [this.options.dappMetadata.logoUrl || \"\"]\n      },\n      rpcMap: Object.fromEntries(this.chains.map(chain => [chain.chainId, chain.rpc[0]]))\n    }));\n  }\n}\n\nasync function _isChainsStale2() {\n  const namespaceMethods = _classPrivateMethodGet(this, _getNamespaceMethods, _getNamespaceMethods2).call(this);\n\n  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n    return false;\n  }\n\n  if (!this.options.isNewChainsStale) {\n    return false;\n  }\n\n  const requestedChains = await _classPrivateMethodGet(this, _getRequestedChainsIds, _getRequestedChainsIds2).call(this);\n  const connectorChains = this.chains.map(_ref3 => {\n    let {\n      chainId\n    } = _ref3;\n    return chainId;\n  });\n\n  const namespaceChains = _classPrivateMethodGet(this, _getNamespaceChainsIds, _getNamespaceChainsIds2).call(this);\n\n  if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) {\n    return false;\n  }\n\n  return !connectorChains.every(id => requestedChains.includes(id));\n}\n\nfunction _removeListeners2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return;\n  }\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"accountsChanged\", this.onAccountsChanged);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"chainChanged\", this.onChainChanged);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"disconnect\", this.onDisconnect);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"session_delete\", this.onDisconnect);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"display_uri\", this.onDisplayUri);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"connect\", this.onConnect);\n}\n\nfunction _setRequestedChainsIds2(chains) {\n  _classPrivateFieldGet(this, _storage).setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));\n}\n\nasync function _getRequestedChainsIds2() {\n  const data = await _classPrivateFieldGet(this, _storage).getItem(REQUESTED_CHAINS_KEY);\n  return data ? JSON.parse(data) : [];\n}\n\nfunction _getNamespaceChainsIds2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return [];\n  }\n\n  const chainIds = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\n  return chainIds ?? [];\n}\n\nfunction _getNamespaceMethods2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return [];\n  }\n\n  const methods = _classPrivateFieldGet(this, _provider).session?.namespaces[NAMESPACE]?.methods;\n  return methods ?? [];\n}\n\nexport { WalletConnectConnector };","map":null,"metadata":{},"sourceType":"module"}