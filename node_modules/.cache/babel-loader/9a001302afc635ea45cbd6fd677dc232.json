{"ast":null,"code":"import { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { T as TWConnector } from '../../../../dist/tw-connector-443c384d.browser.esm.js';\nimport { ethers } from 'ethers';\nimport 'eventemitter3'; // excerpt from https://docs.gnosis-safe.io/backend/available-services\n\nconst CHAIN_ID_TO_GNOSIS_SERVER_URL = {\n  // mainnet\n  1: \"https://safe-transaction-mainnet.safe.global\",\n  // avalanche\n  43114: \"https://safe-transaction-avalanche.safe.global\",\n  // polygon\n  137: \"https://safe-transaction-polygon.safe.global\",\n  // goerli\n  5: \"https://safe-transaction-goerli.safe.global\",\n  // bsc\n  56: \"https://safe-transaction-bsc.safe.global\",\n  // optimism\n  10: \"https://safe-transaction-optimism.safe.global\"\n};\n\nconst __IS_SERVER__ = \"object\" === \"undefined\";\n\nconst SafeSupportedChainsSet = new Set(Object.keys(CHAIN_ID_TO_GNOSIS_SERVER_URL).map(Number));\n\nclass SafeConnector extends TWConnector {\n  // config\n  // private options: SafeOptions;\n  constructor() {\n    super(); // this.options = options;\n\n    _defineProperty(this, \"supportedChains\", SafeConnector.supportedChains);\n\n    _defineProperty(this, \"id\", \"safe-wallet\");\n\n    _defineProperty(this, \"ready\", !__IS_SERVER__);\n\n    _defineProperty(this, \"name\", \"Safe Wallet\");\n\n    _defineProperty(this, \"previousConnector\", void 0);\n\n    _defineProperty(this, \"safeSigner\", void 0);\n\n    _defineProperty(this, \"personalWallet\", void 0);\n\n    {\n      this.ready = true;\n    }\n  }\n\n  async connect(args) {\n    if (!(args.chain.chainId in CHAIN_ID_TO_GNOSIS_SERVER_URL)) {\n      throw new Error(\"Chain not supported by Safe\");\n    }\n\n    this.safeSigner = await this.createSafeSigner(args);\n    return await this.getAddress();\n  }\n\n  async createSafeSigner(params) {\n    this.personalWallet = params.personalWallet;\n    const signer = await params.personalWallet.getSigner();\n    const safeAddress = params.safeAddress;\n    const safeChainId = params.chain.chainId;\n\n    if (!signer) {\n      throw new Error(\"cannot create Gnosis Safe signer without a personal signer\");\n    }\n\n    const signerChainId = await signer.getChainId();\n\n    if (signerChainId !== safeChainId) {\n      throw new Error(\"chainId of personal signer has to match safe chainId\");\n    }\n\n    if (!safeAddress) {\n      throw new Error(\"safeAddress is required\");\n    }\n\n    if (!safeChainId) {\n      throw new Error(\"safeChainId is required\");\n    }\n\n    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];\n\n    if (!serverUrl) {\n      throw new Error(\"Chain not supported\");\n    }\n\n    const [safeEthersAdapters, safeCoreSdk, safeEthersLib] = await Promise.all([import('@safe-global/safe-ethers-adapters'), import('@safe-global/safe-core-sdk'), import('@safe-global/safe-ethers-lib')]);\n    const ethAdapter = new safeEthersLib.default({\n      ethers,\n      signerOrProvider: signer\n    });\n    const safe = await safeCoreSdk.default.create({\n      ethAdapter: ethAdapter,\n      safeAddress\n    });\n    const service = new safeEthersAdapters.SafeService(serverUrl);\n    const safeSigner = new safeEthersAdapters.SafeEthersSigner(safe, service, signer.provider); // See this test for more details:\n    // https://github.com/safe-global/safe-contracts/blob/9d188d3ef514fb7391466a6b5f010db4cc0f3c8b/test/handlers/CompatibilityFallbackHandler.spec.ts#L86-L94\n\n    safeSigner.signMessage = async message => {\n      const EIP712_SAFE_MESSAGE_TYPE = {\n        SafeMessage: [{\n          type: \"bytes\",\n          name: \"message\"\n        }]\n      };\n\n      const encodedMessage = ethers.utils._TypedDataEncoder.hash({\n        verifyingContract: safeAddress,\n        chainId: await this.getChainId()\n      }, EIP712_SAFE_MESSAGE_TYPE, {\n        message: ethers.utils.hashMessage(message)\n      });\n\n      const safeMessage = ethers.utils.arrayify(encodedMessage);\n      const signature = await signer.signMessage(safeMessage);\n      return signature.replace(/1b$/, \"1f\").replace(/1c$/, \"20\");\n    }; // set the personal signer as \"previous connector\" so that we can re-connect to it later when disconnecting\n\n\n    this.previousConnector = params.personalWallet;\n    return safeSigner;\n  }\n\n  async disconnect() {\n    this.safeSigner = undefined;\n    this.previousConnector = undefined;\n    return undefined;\n  }\n\n  async getAddress() {\n    const signer = await this.getSigner();\n    return await signer.getAddress();\n  }\n\n  async getChainId() {\n    return (await this.getSigner()).getChainId();\n  }\n\n  async getProvider() {\n    const provider = (await this.getSigner()).provider;\n\n    if (!provider) {\n      throw new Error(\"No provider available\");\n    }\n\n    return provider;\n  }\n\n  async getSigner() {\n    if (!this.safeSigner) {\n      throw new Error(\"not connected - please call connect() first\");\n    }\n\n    return this.safeSigner;\n  }\n\n  async isConnected() {\n    try {\n      const account = await this.getAddress();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  onAccountsChanged(accounts) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      this.emit(\"change\", {\n        account: ethers.utils.getAddress(accounts[0])\n      });\n    }\n  }\n\n  onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n\n  switchChain() {\n    throw new Error(\"Safe connector does not support switching chains\");\n  }\n\n  updateChains() {}\n\n  async setupListeners() {}\n\n}\n\n_defineProperty(SafeConnector, \"supportedChains\", Object.keys(CHAIN_ID_TO_GNOSIS_SERVER_URL));\n\nexport { SafeConnector, SafeSupportedChainsSet };","map":null,"metadata":{},"sourceType":"module"}