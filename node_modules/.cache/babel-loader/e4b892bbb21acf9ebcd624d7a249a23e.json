{"ast":null,"code":"'use strict';\n\nconst dirBuilder = require('./dir');\n\nconst fileBuilder = require('./file');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('../types').File} File\n * @typedef {import('../types').Directory} Directory\n * @typedef {import('../types').DAGBuilder} DAGBuilder\n * @typedef {import('../types').Chunker} Chunker\n * @typedef {import('../types').ChunkValidator} ChunkValidator\n */\n\n/**\n * @param {any} thing\n * @returns {thing is Iterable<any>}\n */\n\n\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\n/**\n * @param {any} thing\n * @returns {thing is AsyncIterable<any>}\n */\n\n\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\n/**\n * @param {Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>} content\n * @returns {AsyncIterable<Uint8Array>}\n */\n\n\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\n/**\n * @type {DAGBuilder}\n */\n\n\nasync function* dagBuilder(source, block, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n\n    if (entry.content) {\n      /**\n       * @type {Chunker}\n       */\n      let chunker;\n\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = require('../chunker/rabin');\n      } else {\n        chunker = require('../chunker/fixed-size');\n      }\n      /**\n       * @type {ChunkValidator}\n       */\n\n\n      let chunkValidator;\n\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = require('./validate-chunks');\n      }\n      /** @type {File} */\n\n\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, block, options);\n    } else if (entry.path) {\n      /** @type {Directory} */\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, block, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\n\nmodule.exports = dagBuilder;","map":null,"metadata":{},"sourceType":"script"}