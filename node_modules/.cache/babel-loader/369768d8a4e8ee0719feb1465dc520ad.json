{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _Safe_ethAdapter, _Safe_contractManager, _Safe_ownerManager, _Safe_moduleManager, _Safe_guardManager, _Safe_fallbackHandlerManager;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\n\nconst safe_core_sdk_types_1 = require(\"@safe-global/safe-core-sdk-types\");\n\nconst safe_core_sdk_utils_1 = require(\"@safe-global/safe-core-sdk-utils\");\n\nconst contractManager_1 = __importDefault(require(\"./managers/contractManager\"));\n\nconst fallbackHandlerManager_1 = __importDefault(require(\"./managers/fallbackHandlerManager\"));\n\nconst guardManager_1 = __importDefault(require(\"./managers/guardManager\"));\n\nconst moduleManager_1 = __importDefault(require(\"./managers/moduleManager\"));\n\nconst ownerManager_1 = __importDefault(require(\"./managers/ownerManager\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst signatures_1 = require(\"./utils/signatures\");\n\nconst SafeSignature_1 = __importDefault(require(\"./utils/signatures/SafeSignature\"));\n\nconst SafeTransaction_1 = __importDefault(require(\"./utils/transactions/SafeTransaction\"));\n\nconst utils_2 = require(\"./utils/transactions/utils\");\n\nclass Safe {\n  constructor() {\n    _Safe_ethAdapter.set(this, void 0);\n\n    _Safe_contractManager.set(this, void 0);\n\n    _Safe_ownerManager.set(this, void 0);\n\n    _Safe_moduleManager.set(this, void 0);\n\n    _Safe_guardManager.set(this, void 0);\n\n    _Safe_fallbackHandlerManager.set(this, void 0);\n  }\n  /**\n   * Creates an instance of the Safe Core SDK.\n   * @param config - Ethers Safe configuration\n   * @returns The Safe Core SDK instance\n   * @throws \"SafeProxy contract is not deployed on the current network\"\n   * @throws \"MultiSend contract is not deployed on the current network\"\n   * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n   */\n\n\n  static async create(_ref) {\n    let {\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    } = _ref;\n    const safeSdk = new Safe();\n    await safeSdk.init({\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    });\n    return safeSdk;\n  }\n  /**\n   * Initializes the Safe Core SDK instance.\n   * @param config - Safe configuration\n   * @throws \"Signer must be connected to a provider\"\n   * @throws \"SafeProxy contract is not deployed on the current network\"\n   * @throws \"MultiSend contract is not deployed on the current network\"\n   * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n   */\n\n\n  async init(_ref2) {\n    let {\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    } = _ref2;\n\n    __classPrivateFieldSet(this, _Safe_ethAdapter, ethAdapter, \"f\");\n\n    __classPrivateFieldSet(this, _Safe_contractManager, await contractManager_1.default.create({\n      ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"),\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    }), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_guardManager, new guardManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_fallbackHandlerManager, new fallbackHandlerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n  }\n  /**\n   * Returns a new instance of the Safe Core SDK.\n   * @param config - Connect Safe configuration\n   * @throws \"SafeProxy contract is not deployed on the current network\"\n   * @throws \"MultiSend contract is not deployed on the current network\"\n   * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n   */\n\n\n  async connect(_ref3) {\n    let {\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    } = _ref3;\n    return await Safe.create({\n      ethAdapter: ethAdapter || __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"),\n      safeAddress: safeAddress || this.getAddress(),\n      isL1SafeMasterCopy: isL1SafeMasterCopy || __classPrivateFieldGet(this, _Safe_contractManager, \"f\").isL1SafeMasterCopy,\n      contractNetworks: contractNetworks || __classPrivateFieldGet(this, _Safe_contractManager, \"f\").contractNetworks\n    });\n  }\n  /**\n   * Returns the address of the current SafeProxy contract.\n   *\n   * @returns The address of the SafeProxy contract\n   */\n\n\n  getAddress() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getAddress();\n  }\n  /**\n   * Returns the ContractManager\n   *\n   * @returns The current ContractManager\n   * */\n\n\n  getContractManager() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\");\n  }\n  /**\n   * Returns the current EthAdapter.\n   *\n   * @returns The current EthAdapter\n   */\n\n\n  getEthAdapter() {\n    return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\");\n  }\n  /**\n   * Returns the address of the MultiSend contract.\n   *\n   * @returns The address of the MultiSend contract\n   */\n\n\n  getMultiSendAddress() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendContract.getAddress();\n  }\n  /**\n   * Returns the address of the MultiSendCallOnly contract.\n   *\n   * @returns The address of the MultiSendCallOnly contract\n   */\n\n\n  getMultiSendCallOnlyAddress() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendCallOnlyContract.getAddress();\n  }\n  /**\n   * Returns the Safe Master Copy contract version.\n   *\n   * @returns The Safe Master Copy contract version\n   */\n\n\n  async getContractVersion() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getVersion();\n  }\n  /**\n   * Returns the list of Safe owner accounts.\n   *\n   * @returns The list of owners\n   */\n\n\n  async getOwners() {\n    return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").getOwners();\n  }\n  /**\n   * Returns the Safe nonce.\n   *\n   * @returns The Safe nonce\n   */\n\n\n  async getNonce() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getNonce();\n  }\n  /**\n   * Returns the Safe threshold.\n   *\n   * @returns The Safe threshold\n   */\n\n\n  async getThreshold() {\n    return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").getThreshold();\n  }\n  /**\n   * Returns the chainId of the connected network.\n   *\n   * @returns The chainId of the connected network\n   */\n\n\n  async getChainId() {\n    return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getChainId();\n  }\n  /**\n   * Returns the ETH balance of the Safe.\n   *\n   * @returns The ETH balance of the Safe\n   */\n\n\n  async getBalance() {\n    return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getBalance(this.getAddress());\n  }\n  /**\n   * Returns the address of the FallbackHandler contract.\n   *\n   * @returns The address of the FallbackHandler contract\n   */\n\n\n  getFallbackHandler() {\n    return __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").getFallbackHandler();\n  }\n  /**\n   * Returns the enabled Safe guard or 0x address if no guards are enabled.\n   *\n   * @returns The address of the enabled Safe guard\n   * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n   */\n\n\n  async getGuard() {\n    return __classPrivateFieldGet(this, _Safe_guardManager, \"f\").getGuard();\n  }\n  /**\n   * Returns the list of addresses of all the enabled Safe modules.\n   *\n   * @returns The list of addresses of all the enabled Safe modules\n   */\n\n\n  async getModules() {\n    return __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").getModules();\n  }\n  /**\n   * Checks if a specific Safe module is enabled for the current Safe.\n   *\n   * @param moduleAddress - The desired module address\n   * @returns TRUE if the module is enabled\n   */\n\n\n  async isModuleEnabled(moduleAddress) {\n    return __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").isModuleEnabled(moduleAddress);\n  }\n  /**\n   * Checks if a specific address is an owner of the current Safe.\n   *\n   * @param ownerAddress - The account address\n   * @returns TRUE if the account is an owner\n   */\n\n\n  async isOwner(ownerAddress) {\n    return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").isOwner(ownerAddress);\n  }\n  /**\n   * Returns a Safe transaction ready to be signed by the owners.\n   *\n   * @param createTransactionProps - The createTransaction props\n   * @returns The Safe transaction\n   * @throws \"Invalid empty array of transactions\"\n   */\n\n\n  async createTransaction(_ref4) {\n    let {\n      safeTransactionData,\n      onlyCalls = false,\n      options\n    } = _ref4;\n\n    if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length === 0) {\n      throw new Error('Invalid empty array of transactions');\n    }\n\n    let newTransaction;\n\n    if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length > 1) {\n      const multiSendContract = onlyCalls ? __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendCallOnlyContract : __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendContract;\n      const multiSendData = (0, utils_2.encodeMultiSendData)(safeTransactionData.map(utils_2.standardizeMetaTransactionData));\n      const multiSendTransaction = { ...options,\n        to: multiSendContract.getAddress(),\n        value: '0',\n        data: multiSendContract.encode('multiSend', [multiSendData]),\n        operation: safe_core_sdk_types_1.OperationType.DelegateCall\n      };\n      newTransaction = multiSendTransaction;\n    } else {\n      newTransaction = (0, utils_1.isMetaTransactionArray)(safeTransactionData) ? { ...options,\n        ...safeTransactionData[0]\n      } : safeTransactionData;\n    }\n\n    const standardizedTransaction = await (0, utils_2.standardizeSafeTransactionData)(__classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract, __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), newTransaction);\n    return new SafeTransaction_1.default(standardizedTransaction);\n  }\n  /**\n   * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.\n   *\n   * @param nonce - The nonce of the transaction/s that are going to be rejected\n   * @returns The Safe transaction that invalidates the pending Safe transaction/s\n   */\n\n\n  async createRejectionTransaction(nonce) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      nonce,\n      value: '0',\n      data: '0x',\n      safeTxGas: 0\n    };\n    return this.createTransaction({\n      safeTransactionData\n    });\n  }\n  /**\n   * Copies a Safe transaction\n   *\n   * @param safeTransaction - The Safe transaction\n   * @returns The new Safe transaction\n   */\n\n\n  async copyTransaction(safeTransaction) {\n    const signedSafeTransaction = await this.createTransaction({\n      safeTransactionData: safeTransaction.data\n    });\n    safeTransaction.signatures.forEach(signature => {\n      signedSafeTransaction.addSignature(signature);\n    });\n    return signedSafeTransaction;\n  }\n  /**\n   * Returns the transaction hash of a Safe transaction.\n   *\n   * @param safeTransaction - The Safe transaction\n   * @returns The transaction hash of the Safe transaction\n   */\n\n\n  async getTransactionHash(safeTransaction) {\n    const safeTransactionData = safeTransaction.data;\n    const txHash = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getTransactionHash(safeTransactionData);\n    return txHash;\n  }\n  /**\n   * Signs a hash using the current signer account.\n   *\n   * @param hash - The hash to sign\n   * @returns The Safe signature\n   */\n\n\n  async signTransactionHash(hash) {\n    return (0, signatures_1.generateSignature)(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), hash);\n  }\n  /**\n   * Signs a transaction according to the EIP-712 using the current signer account.\n   *\n   * @param safeTransaction - The Safe transaction to be signed\n   * @param methodVersion - EIP-712 version. Optional\n   * @returns The Safe signature\n   */\n\n\n  async signTypedData(safeTransaction, methodVersion) {\n    const safeTransactionEIP712Args = {\n      safeAddress: this.getAddress(),\n      safeVersion: await this.getContractVersion(),\n      chainId: await this.getEthAdapter().getChainId(),\n      safeTransactionData: safeTransaction.data\n    };\n    return (0, signatures_1.generateEIP712Signature)(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), safeTransactionEIP712Args, methodVersion);\n  }\n  /**\n   * Adds the signature of the current signer to the Safe transaction object.\n   *\n   * @param safeTransaction - The Safe transaction to be signed\n   * @param signingMethod - Method followed to sign a transaction. Optional. Default value is \"eth_sign\"\n   * @returns The signed Safe transaction\n   * @throws \"Transactions can only be signed by Safe owners\"\n   */\n\n\n  async signTransaction(safeTransaction) {\n    let signingMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'eth_signTypedData_v4';\n    let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (!signerAddress) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    const addressIsOwner = owners.find(owner => signerAddress && (0, utils_1.sameString)(owner, signerAddress));\n\n    if (!addressIsOwner) {\n      throw new Error('Transactions can only be signed by Safe owners');\n    }\n\n    let signature;\n\n    if (signingMethod === 'eth_signTypedData_v4') {\n      signature = await this.signTypedData(transaction, 'v4');\n    } else if (signingMethod === 'eth_signTypedData_v3') {\n      signature = await this.signTypedData(transaction, 'v3');\n    } else if (signingMethod === 'eth_signTypedData') {\n      signature = await this.signTypedData(transaction);\n    } else {\n      const safeVersion = await this.getContractVersion();\n\n      if (!(0, safe_core_sdk_utils_1.hasSafeFeature)(safe_core_sdk_utils_1.SAFE_FEATURES.ETH_SIGN, safeVersion)) {\n        throw new Error('eth_sign is only supported by Safes >= v1.1.0');\n      }\n\n      const txHash = await this.getTransactionHash(transaction);\n      signature = await this.signTransactionHash(txHash);\n    }\n\n    const signedSafeTransaction = await this.createTransaction({\n      safeTransactionData: transaction.data\n    });\n    transaction.signatures.forEach(signature => {\n      signedSafeTransaction.addSignature(signature);\n    });\n    signedSafeTransaction.addSignature(signature);\n    return signedSafeTransaction;\n  }\n  /**\n   * Approves on-chain a hash using the current signer account.\n   *\n   * @param hash - The hash to approve\n   * @param options - The Safe transaction execution options. Optional\n   * @returns The Safe transaction response\n   * @throws \"Transaction hashes can only be approved by Safe owners\"\n   * @throws \"Cannot specify gas and gasLimit together in transaction options\"\n   */\n\n\n  async approveTransactionHash(hash, options) {\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (!signerAddress) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    const addressIsOwner = owners.find(owner => signerAddress && (0, utils_1.sameString)(owner, signerAddress));\n\n    if (!addressIsOwner) {\n      throw new Error('Transaction hashes can only be approved by Safe owners');\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {\n      throw new Error('Cannot specify gas and gasLimit together in transaction options');\n    }\n\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.approveHash(hash, {\n      from: signerAddress,\n      ...options\n    });\n  }\n  /**\n   * Returns a list of owners who have approved a specific Safe transaction.\n   *\n   * @param txHash - The Safe transaction hash\n   * @returns The list of owners\n   */\n\n\n  async getOwnersWhoApprovedTx(txHash) {\n    const owners = await this.getOwners();\n    let ownersWhoApproved = [];\n\n    for (const owner of owners) {\n      const approved = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.approvedHashes(owner, txHash);\n\n      if (approved.gt(0)) {\n        ownersWhoApproved.push(owner);\n      }\n    }\n\n    return ownersWhoApproved;\n  }\n  /**\n   * Returns the Safe transaction to enable the fallback handler.\n   *\n   * @param address - The new fallback handler address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid fallback handler address provided\"\n   * @throws \"Fallback handler provided is already enabled\"\n   * @throws \"Current version of the Safe does not support the fallback handler functionality\"\n   */\n\n\n  async createEnableFallbackHandlerTx(fallbackHandlerAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").encodeEnableFallbackHandlerData(fallbackHandlerAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to disable the fallback handler.\n   *\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"There is no fallback handler enabled yet\"\n   * @throws \"Current version of the Safe does not support the fallback handler functionality\"\n   */\n\n\n  async createDisableFallbackHandlerTx(options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").encodeDisableFallbackHandlerData(),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to enable a Safe guard.\n   *\n   * @param guardAddress - The desired guard address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid guard address provided\"\n   * @throws \"Guard provided is already enabled\"\n   * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n   */\n\n\n  async createEnableGuardTx(guardAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_guardManager, \"f\").encodeEnableGuardData(guardAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to disable a Safe guard.\n   *\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"There is no guard enabled yet\"\n   * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n   */\n\n\n  async createDisableGuardTx(options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_guardManager, \"f\").encodeDisableGuardData(),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to enable a Safe module.\n   *\n   * @param moduleAddress - The desired module address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid module address provided\"\n   * @throws \"Module provided is already enabled\"\n   */\n\n\n  async createEnableModuleTx(moduleAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").encodeEnableModuleData(moduleAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to disable a Safe module.\n   *\n   * @param moduleAddress - The desired module address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid module address provided\"\n   * @throws \"Module provided is not enabled already\"\n   */\n\n\n  async createDisableModuleTx(moduleAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").encodeDisableModuleData(moduleAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to add an owner and optionally change the threshold.\n   *\n   * @param params - The transaction params\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid owner address provided\"\n   * @throws \"Address provided is already an owner\"\n   * @throws \"Threshold needs to be greater than 0\"\n   * @throws \"Threshold cannot exceed owner count\"\n   */\n\n\n  async createAddOwnerTx(_ref5, options) {\n    let {\n      ownerAddress,\n      threshold\n    } = _ref5;\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeAddOwnerWithThresholdData(ownerAddress, threshold),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to remove an owner and optionally change the threshold.\n   *\n   * @param params - The transaction params\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid owner address provided\"\n   * @throws \"Address provided is not an owner\"\n   * @throws \"Threshold needs to be greater than 0\"\n   * @throws \"Threshold cannot exceed owner count\"\n   */\n\n\n  async createRemoveOwnerTx(_ref6, options) {\n    let {\n      ownerAddress,\n      threshold\n    } = _ref6;\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeRemoveOwnerData(ownerAddress, threshold),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to replace an owner of the Safe with a new one.\n   *\n   * @param params - The transaction params\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid new owner address provided\"\n   * @throws \"Invalid old owner address provided\"\n   * @throws \"New address provided is already an owner\"\n   * @throws \"Old address provided is not an owner\"\n   */\n\n\n  async createSwapOwnerTx(_ref7, options) {\n    let {\n      oldOwnerAddress,\n      newOwnerAddress\n    } = _ref7;\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to change the threshold.\n   *\n   * @param threshold - The new threshold\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Threshold needs to be greater than 0\"\n   * @throws \"Threshold cannot exceed owner count\"\n   */\n\n\n  async createChangeThresholdTx(threshold, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeChangeThresholdData(threshold),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Converts a transaction from type SafeMultisigTransactionResponse to type SafeTransaction\n   *\n   * @param serviceTransactionResponse - The transaction to convert\n   * @returns The converted transaction with type SafeTransaction\n   */\n\n\n  async toSafeTransactionType(serviceTransactionResponse) {\n    var _a;\n\n    const safeTransactionData = {\n      to: serviceTransactionResponse.to,\n      value: serviceTransactionResponse.value,\n      data: serviceTransactionResponse.data || '0x',\n      operation: serviceTransactionResponse.operation,\n      safeTxGas: serviceTransactionResponse.safeTxGas,\n      baseGas: serviceTransactionResponse.baseGas,\n      gasPrice: Number(serviceTransactionResponse.gasPrice),\n      gasToken: serviceTransactionResponse.gasToken,\n      refundReceiver: serviceTransactionResponse.refundReceiver,\n      nonce: serviceTransactionResponse.nonce\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    (_a = serviceTransactionResponse.confirmations) === null || _a === void 0 ? void 0 : _a.map(confirmation => {\n      const signature = new SafeSignature_1.default(confirmation.owner, confirmation.signature);\n      safeTransaction.addSignature(signature);\n    });\n    return safeTransaction;\n  }\n  /**\n   * Checks if a Safe transaction can be executed successfully with no errors.\n   *\n   * @param safeTransaction - The Safe transaction to check\n   * @param options - The Safe transaction execution options. Optional\n   * @returns TRUE if the Safe transaction can be executed successfully with no errors\n   */\n\n\n  async isValidTransaction(safeTransaction, options) {\n    let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;\n    const signedSafeTransaction = await this.copyTransaction(transaction);\n    const txHash = await this.getTransactionHash(signedSafeTransaction);\n    const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);\n\n    for (const owner of ownersWhoApprovedTx) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));\n    }\n\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (!signerAddress) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    if (owners.includes(signerAddress)) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));\n    }\n\n    const isTxValid = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.isValidTransaction(signedSafeTransaction, {\n      from: signerAddress,\n      ...options\n    });\n    return isTxValid;\n  }\n  /**\n   * Executes a Safe transaction.\n   *\n   * @param safeTransaction - The Safe transaction to execute\n   * @param options - The Safe transaction execution options. Optional\n   * @returns The Safe transaction response\n   * @throws \"No signer provided\"\n   * @throws \"There are X signatures missing\"\n   * @throws \"Cannot specify gas and gasLimit together in transaction options\"\n   */\n\n\n  async executeTransaction(safeTransaction, options) {\n    let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;\n    const signedSafeTransaction = await this.copyTransaction(transaction);\n    const txHash = await this.getTransactionHash(signedSafeTransaction);\n    const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);\n\n    for (const owner of ownersWhoApprovedTx) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));\n    }\n\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (signerAddress && owners.includes(signerAddress)) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));\n    }\n\n    const threshold = await this.getThreshold();\n\n    if (threshold > signedSafeTransaction.signatures.size) {\n      const signaturesMissing = threshold - signedSafeTransaction.signatures.size;\n      throw new Error(`There ${signaturesMissing > 1 ? 'are' : 'is'} ${signaturesMissing} signature${signaturesMissing > 1 ? 's' : ''} missing`);\n    }\n\n    const value = bignumber_1.BigNumber.from(signedSafeTransaction.data.value);\n\n    if (!value.isZero()) {\n      const balance = await this.getBalance();\n\n      if (value.gt(bignumber_1.BigNumber.from(balance))) {\n        throw new Error('Not enough Ether funds');\n      }\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {\n      throw new Error('Cannot specify gas and gasLimit together in transaction options');\n    }\n\n    const txResponse = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.execTransaction(signedSafeTransaction, {\n      from: signerAddress,\n      ...options\n    });\n    return txResponse;\n  }\n\n}\n\n_Safe_ethAdapter = new WeakMap(), _Safe_contractManager = new WeakMap(), _Safe_ownerManager = new WeakMap(), _Safe_moduleManager = new WeakMap(), _Safe_guardManager = new WeakMap(), _Safe_fallbackHandlerManager = new WeakMap();\nexports.default = Safe; //# sourceMappingURL=Safe.js.map","map":null,"metadata":{},"sourceType":"script"}