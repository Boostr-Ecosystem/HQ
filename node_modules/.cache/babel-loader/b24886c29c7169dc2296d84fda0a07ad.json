{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ACESFilmicToneMapping, EventDispatcher, sRGBEncoding, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode, resolveDpr } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { Debugger } from './Debugger.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js'; // Between 0 and 1: larger means the average responds faster and is less smooth.\n\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\n\nexport class Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.debugger = null;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.lastTick = performance.now();\n    this.renderedLastFrame = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n\n    this.onWebGLContextRestored = () => {\n      var _a;\n\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n    };\n\n    this.dpr = resolveDpr();\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = sRGBEncoding;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n\n      this.debugger = !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!this.debugger\n      }; // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n  }\n\n  static get singleton() {\n    return this._singleton;\n  }\n\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n\n  set minScale(scale) {\n    let i = 1;\n\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n\n      ++i;\n    }\n\n    this.lastStep = i - 1;\n  }\n\n  registerScene(scene) {\n    this.scenes.add(scene);\n    scene.forceRescale();\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement.removeChild(this.canvas3D);\n    }\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n\n  displayCanvas(scene) {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n\n\n  countVisibleScenes() {\n    const {\n      canvas3D\n    } = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n\n    const multipleScenesVisible = visibleScenes > 1;\n\n    if (canvas3DScene != null) {\n      const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n\n      if (newlyMultiple || disappearing) {\n        const {\n          width,\n          height\n        } = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement.removeChild(canvas3D);\n      }\n    }\n\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n\n\n  updateRendererSize() {\n    const dpr = resolveDpr();\n\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    } // Make the renderer the size of the largest scene\n\n\n    let width = 0;\n    let height = 0;\n\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    } // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n\n\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n    }\n  }\n\n  updateRendererScale(delta) {\n    const scaleStep = this.scaleStep;\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n\n  shouldRender(scene) {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n\n    return true;\n  }\n\n  rescaleCanvas(scene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n    const {\n      style\n    } = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n\n  sceneSize(scene) {\n    const {\n      dpr\n    } = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep]; // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n\n    const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {\n      width,\n      height\n    };\n  }\n\n  copyPixels(scene, width, height) {\n    const context2D = scene.context;\n\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n\n\n  orderedScenes() {\n    const scenes = [];\n\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n\n    return scenes;\n  }\n\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n\n\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n  }\n\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    this.countVisibleScenes();\n    this.updateRendererSize();\n\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n\n    const {\n      canvas3D\n    } = this;\n\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n\n      if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n\n      const {\n        width,\n        height\n      } = this.sceneSize(scene);\n      scene.renderShadow(this.threeRenderer); // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n      this.threeRenderer.render(scene, scene.camera);\n\n      if (this.multipleScenesVisible || scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else {\n        if (canvas3D.parentElement !== scene.canvas.parentElement) {\n          scene.canvas.parentElement.appendChild(canvas3D);\n          scene.canvas.classList.remove('show');\n        }\n      }\n\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n\n}\nRenderer._singleton = new Renderer({\n  powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n  debug: isDebugMode()\n}); //# sourceMappingURL=Renderer.js.map","map":null,"metadata":{},"sourceType":"module"}