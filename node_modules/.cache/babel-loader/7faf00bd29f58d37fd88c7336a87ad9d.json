{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nconst Base_1 = __importDefault(require(\"./Base\")); // @credit: https://github.com/wanseob/solidity-mmr\n\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\n\n\nclass MerkleMountainRange extends Base_1.default {\n  constructor() {\n    let hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    let leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    let peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    let hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n    super();\n    this.root = buffer_1.Buffer.alloc(0);\n    this.size = 0;\n    this.width = 0;\n    this.hashes = {};\n    this.data = {};\n    leaves = leaves.map(this.bufferify);\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.hashLeafFn = hashLeafFn;\n    this.peakBaggingFn = peakBaggingFn;\n    this.hashBranchFn = hashBranchFn;\n\n    for (const leaf of leaves) {\n      this.append(leaf);\n    }\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n\n\n  append(data) {\n    data = this.bufferify(data);\n    const dataHash = this.hashFn(data);\n    const dataHashHex = this.bufferToHex(dataHash);\n\n    if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n      this.data[dataHashHex] = data;\n    }\n\n    const leaf = this.hashLeaf(this.size + 1, dataHash);\n    this.hashes[this.size + 1] = leaf;\n    this.width += 1; // find peaks for enlarged tree\n\n    const peakIndexes = this.getPeakIndexes(this.width); // the right most peak's value is the new size of the updated tree\n\n    this.size = this.getSize(this.width); // starting from the left-most peak, get all peak hashes\n\n    const peaks = [];\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n    } // update the tree root hash\n\n\n    this.root = this.peakBagging(this.width, peaks);\n  }\n  /**\n   * @desc It returns the hash of a leaf node with hash(M | DATA )\n   *       M is the index of the node.\n   */\n\n\n  hashLeaf(index, dataHash) {\n    dataHash = this.bufferify(dataHash);\n\n    if (this.hashLeafFn) {\n      return this.bufferify(this.hashLeafFn(index, dataHash));\n    }\n\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n  }\n  /**\n   * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n   *       M is the index of the node.\n   */\n\n\n  hashBranch(index, left, right) {\n    if (this.hashBranchFn) {\n      return this.bufferify(this.hashBranchFn(index, left, right));\n    }\n\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n  }\n\n  getPeaks() {\n    const peakIndexes = this.getPeakIndexes(this.width);\n    const peaks = [];\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this.hashes[peakIndexes[i]];\n    }\n\n    return peaks;\n  }\n\n  getLeafIndex(width) {\n    if (width % 2 === 1) {\n      return this.getSize(width);\n    }\n\n    return this.getSize(width - 1) + 1;\n  }\n  /**\n   * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n   *       the given index(size).\n   */\n\n\n  getPeakIndexes(width) {\n    const numPeaks = this.numOfPeaks(width);\n    const peakIndexes = [];\n    let count = 0;\n    let size = 0;\n\n    for (let i = 255; i > 0; i--) {\n      if ((width & 1 << i - 1) !== 0) {\n        // peak exists\n        size = size + (1 << i) - 1;\n        peakIndexes[count++] = size;\n\n        if (peakIndexes.length >= numPeaks) {\n          break;\n        }\n      }\n    }\n\n    if (count !== peakIndexes.length) {\n      throw new Error('invalid bit calculation');\n    }\n\n    return peakIndexes;\n  }\n\n  numOfPeaks(width) {\n    let bits = width;\n    let num = 0;\n\n    while (bits > 0) {\n      if (bits % 2 === 1) {\n        num++;\n      }\n\n      bits = bits >> 1;\n    }\n\n    return num;\n  }\n\n  peakBagging(width, peaks) {\n    const size = this.getSize(width);\n\n    if (this.numOfPeaks(width) !== peaks.length) {\n      throw new Error('received invalid number of peaks');\n    }\n\n    if (width === 0 && !peaks.length) {\n      return buffer_1.Buffer.alloc(0);\n    }\n\n    if (this.peakBaggingFn) {\n      return this.bufferify(this.peakBaggingFn(size, peaks));\n    }\n\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n  }\n  /**\n   * @desc It returns the size of the tree.\n   */\n\n\n  getSize(width) {\n    return (width << 1) - this.numOfPeaks(width);\n  }\n  /**\n   * @desc It returns the root value of the tree.\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n   */\n\n\n  getNode(index) {\n    return this.hashes[index];\n  }\n  /**\n   * @desc It returns the height of the highest peak.\n   */\n\n\n  mountainHeight(size) {\n    let height = 1;\n\n    while (1 << height <= size + height) {\n      height++;\n    }\n\n    return height - 1;\n  }\n  /**\n   * @desc It returns the height of the index.\n   */\n\n\n  heightAt(index) {\n    let reducedIndex = index;\n    let peakIndex = 0;\n    let height = 0; // if an index has a left mountain then subtract the mountain\n\n    while (reducedIndex > peakIndex) {\n      reducedIndex -= (1 << height) - 1;\n      height = this.mountainHeight(reducedIndex);\n      peakIndex = (1 << height) - 1;\n    } // index is on the right slope\n\n\n    return height - (peakIndex - reducedIndex);\n  }\n  /**\n   * @desc It returns whether the index is the leaf node or not\n   */\n\n\n  isLeaf(index) {\n    return this.heightAt(index) === 1;\n  }\n  /**\n   * @desc It returns the children when it is a parent node.\n   */\n\n\n  getChildren(index) {\n    const left = index - (1 << this.heightAt(index) - 1);\n    const right = index - 1;\n\n    if (left === right) {\n      throw new Error('not a parent');\n    }\n\n    return [left, right];\n  }\n  /**\n   * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n   */\n\n\n  getMerkleProof(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n\n    if (!this.isLeaf(index)) {\n      throw new Error('not a leaf');\n    }\n\n    const root = this.root;\n    const width = this.width; // find all peaks for bagging\n\n    const peaks = this.getPeakIndexes(this.width);\n    const peakBagging = [];\n    let cursor = 0;\n\n    for (let i = 0; i < peaks.length; i++) {\n      // collect the hash of all peaks\n      peakBagging[i] = this.hashes[peaks[i]]; // find the peak which includes the target index\n\n      if (peaks[i] >= index && cursor === 0) {\n        cursor = peaks[i];\n      }\n    }\n\n    let left = 0;\n    let right = 0; // get hashes of the siblings in the mountain which the index belgons to.\n    // it moves the cursor from the summit of the mountain down to the target index\n\n    let height = this.heightAt(cursor);\n    const siblings = [];\n\n    while (cursor !== index) {\n      height--;\n      [left, right] = this.getChildren(cursor); // move the cursor down to the left size or right size\n\n      cursor = index <= left ? left : right; // remaining node is the sibling\n\n      siblings[height - 1] = this.hashes[index <= left ? right : left];\n    }\n\n    return {\n      root,\n      width,\n      peakBagging,\n      siblings\n    };\n  }\n  /**\n   * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n   */\n\n\n  verify(root, width, index, value, peaks, siblings) {\n    value = this.bufferify(value);\n    const size = this.getSize(width);\n\n    if (size < index) {\n      throw new Error('index is out of range');\n    } // check the root equals the peak bagging hash\n\n\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    } // find the mountain where the target index belongs to\n\n\n    let cursor = 0;\n    let targetPeak;\n    const peakIndexes = this.getPeakIndexes(width);\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      if (peakIndexes[i] >= index) {\n        targetPeak = peaks[i];\n        cursor = peakIndexes[i];\n        break;\n      }\n    }\n\n    if (!targetPeak) {\n      throw new Error('target not found');\n    } // find the path climbing down\n\n\n    let height = siblings.length + 1;\n    const path = new Array(height);\n    let left = 0;\n    let right = 0;\n\n    while (height > 0) {\n      // record the current cursor and climb down\n      path[--height] = cursor;\n\n      if (cursor === index) {\n        // on the leaf node. Stop climbing down\n        break;\n      } else {\n        // on the parent node. Go left or right\n        [left, right] = this.getChildren(cursor);\n        cursor = index > left ? right : left;\n        continue;\n      }\n    } // calculate the summit hash climbing up again\n\n\n    let node;\n\n    while (height < path.length) {\n      // move cursor\n      cursor = path[height];\n\n      if (height === 0) {\n        // cusor is on the leaf\n        node = this.hashLeaf(cursor, this.hashFn(value));\n      } else if (cursor - 1 === path[height - 1]) {\n        // cursor is on a parent and a siblings is on the left\n        node = this.hashBranch(cursor, siblings[height - 1], node);\n      } else {\n        // cursor is on a parent and a siblings is on the right\n        node = this.hashBranch(cursor, node, siblings[height - 1]);\n      } // climb up\n\n\n      height++;\n    } // computed hash value of the summit should equal to the target peak hash\n\n\n    if (!node.equals(targetPeak)) {\n      throw new Error('hashed peak is invalid');\n    }\n\n    return true;\n  }\n\n  peaksToPeakMap(width, peaks) {\n    const peakMap = {};\n    let bitIndex = 0;\n    let peakRef = 0;\n    let count = peaks.length;\n\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n      peakRef = 1 << height - 1;\n\n      if ((width & peakRef) !== 0) {\n        peakMap[bitIndex] = peaks[--count];\n      } else {\n        peakMap[bitIndex] = 0;\n      }\n    }\n\n    if (count !== 0) {\n      throw new Error('invalid number of peaks');\n    }\n\n    return peakMap;\n  }\n\n  peakMapToPeaks(width, peakMap) {\n    const arrLength = this.numOfPeaks(width);\n    const peaks = new Array(arrLength);\n    let count = 0;\n\n    for (let i = 0; i < 32; i++) {\n      if (peakMap[i] !== 0) {\n        peaks[count++] = peakMap[i];\n      }\n    }\n\n    if (count !== arrLength) {\n      throw new Error('invalid number of peaks');\n    }\n\n    return peaks;\n  }\n\n  peakUpdate(width, prevPeakMap, itemHash) {\n    const nextPeakMap = {};\n    const newWidth = width + 1;\n    let cursorIndex = this.getLeafIndex(newWidth);\n    let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n    let bitIndex = 0;\n    let peakRef = 0;\n    let prevPeakExist = false;\n    let nextPeakExist = false;\n    let obtained = false;\n\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n\n      if (obtained) {\n        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n      } else {\n        peakRef = 1 << height - 1;\n        prevPeakExist = (width & peakRef) !== 0;\n        nextPeakExist = (newWidth & peakRef) !== 0; // get new cursor node with hashing the peak and the current cursor\n\n        cursorIndex++;\n\n        if (prevPeakExist) {\n          cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n        } // if new peak exists for the bit index\n\n\n        if (nextPeakExist) {\n          // if prev peak exists for the bit index\n          if (prevPeakExist) {\n            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n          } else {\n            nextPeakMap[bitIndex] = cursorNode;\n          }\n\n          obtained = true;\n        } else {\n          nextPeakMap[bitIndex] = 0;\n        }\n      }\n    }\n\n    return nextPeakMap;\n  }\n\n  rollUp(root, width, peaks, itemHashes) {\n    // check the root equals the peak bagging hash\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    }\n\n    let tmpWidth = width;\n    let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n\n    for (let i = 0; i < itemHashes.length; i++) {\n      tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n      tmpWidth++;\n    }\n\n    return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n  }\n  /**\n   * @desc It returns the hash value of the node for the index.\n   *      If the hash already exists it simply returns the stored value. On the other hand,\n   *      it computes hashes recursively downward.\n   *      Only appending an item calls this function.\n   */\n\n\n  _getOrCreateNode(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n\n    if (!this.hashes[index]) {\n      const [leftIndex, rightIndex] = this.getChildren(index);\n\n      const leftHash = this._getOrCreateNode(leftIndex);\n\n      const rightHash = this._getOrCreateNode(rightIndex);\n\n      this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n    }\n\n    return this.hashes[index];\n  }\n\n}\n\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":null,"metadata":{},"sourceType":"script"}