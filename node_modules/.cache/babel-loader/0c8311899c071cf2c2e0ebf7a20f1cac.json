{"ast":null,"code":"import { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { providers, Contract, utils } from 'ethers';\nimport EventEmitter from 'eventemitter3'; // TODO improve this\n\nfunction chainIdToThirdwebRpc(chainId) {\n  return `https://${chainId}.rpc.thirdweb.com`;\n}\n\nconst EIP1271_ABI = [\"function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)\"];\nconst EIP1271_MAGICVALUE = \"0x1626ba7e\";\n\nasync function checkContractWalletSignature(message, signature, address, chainId) {\n  const provider = new providers.JsonRpcProvider(chainIdToThirdwebRpc(chainId));\n  const walletContract = new Contract(address, EIP1271_ABI, provider);\n\n  const _hashMessage = utils.hashMessage(message);\n\n  try {\n    const res = await walletContract.isValidSignature(_hashMessage, signature);\n    return res === EIP1271_MAGICVALUE;\n  } catch {\n    return false;\n  }\n}\n\nclass AbstractWallet extends EventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"type\", \"evm\");\n\n    _defineProperty(this, \"signerPromise\", void 0);\n  }\n  /**\n   * @returns the account address from connected wallet\n   */\n\n\n  async getAddress() {\n    const signer = await this.getCachedSigner();\n    return signer.getAddress();\n  }\n  /**\n   * @returns the chain id from connected wallet\n   */\n\n\n  async getChainId() {\n    const signer = await this.getCachedSigner();\n    return signer.getChainId();\n  }\n  /**\n   * @returns the signature of the message\n   */\n\n\n  async signMessage(message) {\n    const signer = await this.getCachedSigner();\n    return await signer.signMessage(message);\n  }\n  /**\n   * verify the signature of a message\n   * @returns `true` if the signature is valid, `false` otherwise\n   */\n\n\n  async verifySignature(message, signature, address, chainId) {\n    const messageHash = utils.hashMessage(message);\n    const messageHashBytes = utils.arrayify(messageHash);\n    const recoveredAddress = utils.recoverAddress(messageHashBytes, signature);\n\n    if (recoveredAddress === address) {\n      return true;\n    } // Check if the address is a smart contract wallet\n\n\n    if (chainId !== undefined) {\n      try {\n        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);\n        return isValid;\n      } catch {// no-op\n      }\n    }\n\n    return false;\n  }\n\n  async getCachedSigner() {\n    // if we already have a signer promise, return that\n    if (this.signerPromise) {\n      return this.signerPromise;\n    }\n\n    this.signerPromise = this.getSigner().catch(() => {\n      this.signerPromise = undefined;\n      throw new Error(\"Unable to get a signer!\");\n    });\n    return this.signerPromise;\n  }\n\n}\n\nexport { AbstractWallet, checkContractWalletSignature };","map":null,"metadata":{},"sourceType":"module"}