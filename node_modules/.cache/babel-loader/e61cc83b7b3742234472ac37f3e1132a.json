{"ast":null,"code":"import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-eea39a9a.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { AbstractWallet } from '../../abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport { a as AbstractBrowserWallet, c as createAsyncLocalStorage } from '../../../../dist/base-26952412.browser.esm.js';\nimport { Ethereum, defaultChains } from '@thirdweb-dev/chains';\nimport { ethers } from 'ethers';\nimport '../../../../dist/checkPrivateRedeclaration-3aaaa21d.browser.esm.js';\nimport 'eventemitter3';\nimport '../../../../dist/classPrivateMethodGet-9d546189.browser.esm.js'; // no need for prefixing here - AsyncStorage is already namespaced\n\nconst STORAGE_KEY_DATA = \"data\";\nconst STORAGE_KEY_ADDR = \"address\";\n\nvar _walletImpl = /*#__PURE__*/new WeakMap();\n\nclass DeviceBrowserWallet extends AbstractBrowserWallet {\n  get walletName() {\n    return \"Device Wallet\";\n  }\n\n  constructor(options) {\n    super(DeviceBrowserWallet.id, { ...options\n    });\n\n    _defineProperty(this, \"connector\", void 0);\n\n    _classPrivateFieldInitSpec(this, _walletImpl, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"options\", void 0);\n\n    this.options = options;\n  }\n\n  async getConnector() {\n    if (!this.connector) {\n      // import the connector dynamically\n      const {\n        DeviceWalletConnector\n      } = await import('../../../connectors/device-wallet/dist/thirdweb-dev-wallets-evm-connectors-device-wallet.browser.esm.js');\n      let wallet;\n\n      switch (this.options.storageType) {\n        case \"asyncStore\":\n          wallet = await DeviceWalletImpl.fromAsyncStorage(this.options.storage || createAsyncLocalStorage(\"deviceWallet\"));\n          break;\n\n        case \"credentialStore\":\n          wallet = await DeviceWalletImpl.fromCredentialStore();\n          break;\n\n        default:\n          // default to local storage\n          wallet = await DeviceWalletImpl.fromAsyncStorage(this.options.storage || createAsyncLocalStorage(\"deviceWallet\"));\n      }\n\n      this.connector = new DeviceWalletConnector({\n        chain: this.options.chain || Ethereum,\n        wallet,\n        chains: this.options.chains || defaultChains\n      });\n\n      _classPrivateFieldSet(this, _walletImpl, wallet);\n    }\n\n    return this.connector;\n  }\n\n  getWalletData() {\n    if (!_classPrivateFieldGet(this, _walletImpl)) {\n      throw new Error(\"Wallet not initialized\");\n    }\n\n    return _classPrivateFieldGet(this, _walletImpl).getWalletData();\n  }\n\n  static getAddressStorageKey() {\n    return STORAGE_KEY_ADDR;\n  }\n\n  static getDataStorageKey() {\n    return STORAGE_KEY_DATA;\n  }\n\n}\n\n_defineProperty(DeviceBrowserWallet, \"id\", \"deviceWallet\");\n\n_defineProperty(DeviceBrowserWallet, \"meta\", {\n  name: \"Device Wallet\",\n  iconURL: \"ipfs://QmcNddbYBuQKiBFnPcxYegjrX6S6z9K1vBNzbBBUJMn2ox/device-wallet.svg\"\n});\n\nvar _wallet = /*#__PURE__*/new WeakMap();\n\nclass DeviceWalletImpl extends AbstractWallet {\n  static async fromAsyncStorage(storage) {\n    return new DeviceWalletImpl({\n      storage: new AsyncWalletStorage(storage)\n    });\n  }\n\n  static async fromCredentialStore() {\n    return new DeviceWalletImpl({\n      storage: new CredentialsStorage(navigator.credentials)\n    });\n  }\n\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"options\", void 0);\n\n    _classPrivateFieldInitSpec(this, _wallet, {\n      writable: true,\n      value: void 0\n    });\n\n    this.options = options;\n  }\n\n  async getSigner(provider) {\n    if (!_classPrivateFieldGet(this, _wallet)) {\n      throw new Error(\"Wallet not initialized\");\n    }\n\n    let wallet = _classPrivateFieldGet(this, _wallet);\n\n    if (provider) {\n      wallet = wallet.connect(provider);\n    }\n\n    return wallet;\n  }\n\n  async getSavedWalletAddress() {\n    const data = await this.options.storage.getWalletData();\n\n    if (!data) {\n      return null;\n    }\n\n    return data.address;\n  }\n\n  async generateNewWallet() {\n    const wallet = ethers.Wallet.createRandom();\n\n    _classPrivateFieldSet(this, _wallet, wallet);\n\n    return wallet.address;\n  }\n\n  async loadSavedWallet(password) {\n    const data = await this.options.storage.getWalletData();\n\n    if (!data) {\n      throw new Error(\"No saved wallet\");\n    }\n\n    const wallet = await ethers.Wallet.fromEncryptedJson(data.encryptedData, password);\n\n    _classPrivateFieldSet(this, _wallet, wallet);\n\n    return wallet.address;\n  }\n\n  async save(password) {\n    const wallet = await this.getSigner(); // reduce the scrypt cost to make it faster\n\n    const options = {\n      scrypt: {\n        N: 1 << 32\n      }\n    };\n    const encryptedData = await wallet.encrypt(password, options);\n    await this.options.storage.storeWalletData({\n      address: wallet.address,\n      encryptedData\n    });\n  }\n\n  async export(password) {\n    const wallet = await this.getSigner();\n    return wallet.encrypt(password);\n  }\n\n  getWalletData() {\n    return this.options.storage.getWalletData();\n  }\n\n}\n\nclass AsyncWalletStorage {\n  constructor(storage) {\n    _defineProperty(this, \"storage\", void 0);\n\n    this.storage = storage;\n  }\n\n  async getWalletData() {\n    const [address, encryptedData] = await Promise.all([this.storage.getItem(STORAGE_KEY_ADDR), this.storage.getItem(STORAGE_KEY_DATA)]);\n\n    if (!address || !encryptedData) {\n      return null;\n    }\n\n    return {\n      address,\n      encryptedData\n    };\n  }\n\n  async storeWalletData(data) {\n    await Promise.all([this.storage.setItem(STORAGE_KEY_ADDR, data.address), this.storage.setItem(STORAGE_KEY_DATA, data.encryptedData)]);\n  }\n\n}\n\nclass CredentialsStorage {\n  constructor(container) {\n    _defineProperty(this, \"container\", void 0);\n\n    this.container = container;\n  }\n\n  async getWalletData() {\n    const credential = await this.container.get({\n      password: true,\n      unmediated: true\n    });\n\n    if (credential && \"password\" in credential) {\n      return {\n        address: credential.id,\n        encryptedData: credential.password\n      };\n    }\n\n    return null;\n  }\n\n  async storeWalletData(data) {\n    if (\"PasswordCredential\" in window) {\n      let credentialData = {\n        id: data.address,\n        password: data.encryptedData\n      };\n      const credential = await this.container.create({\n        password: credentialData\n      });\n\n      if (!credential) {\n        throw new Error(\"Credential not created\");\n      }\n\n      await this.container.store(credential);\n    } else {\n      throw new Error(\"PasswordCredential not supported\");\n    }\n  }\n\n}\n\nexport { DeviceBrowserWallet, DeviceWalletImpl };","map":null,"metadata":{},"sourceType":"module"}