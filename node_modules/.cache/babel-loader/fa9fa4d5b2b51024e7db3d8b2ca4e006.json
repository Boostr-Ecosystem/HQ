{"ast":null,"code":"import { proxy as u, subscribe as f } from \"valtio/vanilla\";\nimport { Buffer as U } from \"buffer\";\nlet L;\nconst p = {\n  ethereumClient: void 0,\n\n  setEthereumClient(e) {\n    L = e;\n  },\n\n  client() {\n    if (L) return L;\n    throw new Error(\"ClientCtrl has no client set\");\n  }\n\n},\n      o = u({\n  address: void 0,\n  profileName: void 0,\n  profileAvatar: void 0,\n  profileLoading: !1,\n  balanceLoading: !1,\n  balance: void 0,\n  isConnected: !1\n}),\n      A = {\n  state: o,\n\n  subscribe(e) {\n    return f(o, () => e(o));\n  },\n\n  getAccount() {\n    const e = p.client().getAccount();\n    o.address = e.address, o.isConnected = e.isConnected;\n  },\n\n  async fetchProfile(e, t) {\n    try {\n      o.profileLoading = !0;\n      const n = t ?? o.address,\n            {\n        id: a\n      } = p.client().getDefaultChain();\n\n      if (n && a === 1) {\n        const [l, c] = await Promise.all([p.client().fetchEnsName({\n          address: n,\n          chainId: 1\n        }), p.client().fetchEnsAvatar({\n          address: n,\n          chainId: 1\n        })]);\n        c && (await e(c)), o.profileName = l, o.profileAvatar = c;\n      }\n    } finally {\n      o.profileLoading = !1;\n    }\n  },\n\n  async fetchBalance(e) {\n    try {\n      o.balanceLoading = !0;\n      const t = e ?? o.address;\n\n      if (t) {\n        const n = await p.client().fetchBalance({\n          address: t\n        });\n        o.balance = {\n          amount: n.formatted,\n          symbol: n.symbol\n        };\n      }\n    } finally {\n      o.balanceLoading = !1;\n    }\n  },\n\n  setAddress(e) {\n    o.address = e;\n  },\n\n  setIsConnected(e) {\n    o.isConnected = e;\n  },\n\n  resetBalance() {\n    o.balance = void 0;\n  },\n\n  resetAccount() {\n    o.address = void 0, o.isConnected = !1, o.profileName = void 0, o.profileAvatar = void 0, o.balance = void 0;\n  }\n\n},\n      d = {\n  WALLETCONNECT_DEEPLINK_CHOICE: \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  W3M_VERSION: \"W3M_VERSION\",\n\n  isMobile() {\n    return typeof window < \"u\" ? !!(window.matchMedia(\"(pointer:coarse)\").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;\n  },\n\n  isAndroid() {\n    return d.isMobile() && navigator.userAgent.toLowerCase().includes(\"android\");\n  },\n\n  isEmptyObject(e) {\n    return Object.getPrototypeOf(e) === Object.prototype && Object.getOwnPropertyNames(e).length === 0 && Object.getOwnPropertySymbols(e).length === 0;\n  },\n\n  isHttpUrl(e) {\n    return e.startsWith(\"http://\") || e.startsWith(\"https://\");\n  },\n\n  formatNativeUrl(e, t, n) {\n    if (d.isHttpUrl(e)) return this.formatUniversalUrl(e, t, n);\n    let a = e;\n    a.includes(\"://\") || (a = e.replaceAll(\"/\", \"\").replaceAll(\":\", \"\"), a = `${a}://`), this.setWalletConnectDeepLink(a, n);\n    const l = encodeURIComponent(t);\n    return `${a}wc?uri=${l}`;\n  },\n\n  formatUniversalUrl(e, t, n) {\n    if (!d.isHttpUrl(e)) return this.formatNativeUrl(e, t, n);\n    let a = e;\n    e.endsWith(\"/\") && (a = e.slice(0, -1)), this.setWalletConnectDeepLink(a, n);\n    const l = encodeURIComponent(t);\n    return `${a}/wc?uri=${l}`;\n  },\n\n  async wait(e) {\n    return new Promise(t => {\n      setTimeout(t, e);\n    });\n  },\n\n  openHref(e, t) {\n    window.open(e, t, \"noreferrer noopener\");\n  },\n\n  setWalletConnectDeepLink(e, t) {\n    localStorage.setItem(d.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({\n      href: e,\n      name: t\n    }));\n  },\n\n  setWalletConnectAndroidDeepLink(e) {\n    const [t] = e.split(\"?\");\n    localStorage.setItem(d.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({\n      href: t,\n      name: \"Android\"\n    }));\n  },\n\n  removeWalletConnectDeepLink() {\n    localStorage.removeItem(d.WALLETCONNECT_DEEPLINK_CHOICE);\n  },\n\n  isNull(e) {\n    return e === null;\n  },\n\n  setWeb3ModalVersionInStorage() {\n    typeof localStorage < \"u\" && localStorage.setItem(d.W3M_VERSION, \"2.2.2\");\n  }\n\n},\n      s = u({\n  selectedChain: void 0,\n  chains: void 0,\n  standaloneChains: void 0,\n  standaloneUri: void 0,\n  isStandalone: !1,\n  isCustomDesktop: !1,\n  isCustomMobile: !1,\n  isDataLoaded: !1,\n  isUiLoaded: !1,\n  walletConnectVersion: 1\n}),\n      i = {\n  state: s,\n\n  subscribe(e) {\n    return f(s, () => e(s));\n  },\n\n  setChains(e) {\n    s.chains = e;\n  },\n\n  setStandaloneChains(e) {\n    s.standaloneChains = e;\n  },\n\n  setStandaloneUri(e) {\n    s.standaloneUri = e;\n  },\n\n  getSelectedChain() {\n    const e = p.client().getNetwork().chain;\n    return e && (s.selectedChain = e), s.selectedChain;\n  },\n\n  setSelectedChain(e) {\n    s.selectedChain = e;\n  },\n\n  setIsStandalone(e) {\n    s.isStandalone = e;\n  },\n\n  setIsCustomDesktop(e) {\n    s.isCustomDesktop = e;\n  },\n\n  setIsCustomMobile(e) {\n    s.isCustomMobile = e;\n  },\n\n  setIsDataLoaded(e) {\n    s.isDataLoaded = e;\n  },\n\n  setIsUiLoaded(e) {\n    s.isUiLoaded = e;\n  },\n\n  setWalletConnectVersion(e) {\n    s.walletConnectVersion = e;\n  }\n\n},\n      b = u({\n  projectId: \"\",\n  mobileWallets: void 0,\n  desktopWallets: void 0,\n  walletImages: void 0,\n  chainImages: void 0,\n  tokenImages: void 0,\n  standaloneChains: void 0,\n  enableStandaloneMode: !1,\n  enableNetworkView: !1,\n  enableAccountView: !0,\n  enableExplorer: !0,\n  defaultChain: void 0,\n  explorerAllowList: void 0,\n  explorerDenyList: void 0,\n  termsOfServiceUrl: void 0,\n  privacyPolicyUrl: void 0\n}),\n      S = {\n  state: b,\n\n  subscribe(e) {\n    return f(b, () => e(b));\n  },\n\n  setConfig(e) {\n    var t, n, a, l;\n\n    if (i.setStandaloneChains(e.standaloneChains), i.setIsStandalone(!!((t = e.standaloneChains) != null && t.length) || !!e.enableStandaloneMode), i.setIsCustomMobile(!!((n = e.mobileWallets) != null && n.length)), i.setIsCustomDesktop(!!((a = e.desktopWallets) != null && a.length)), i.setWalletConnectVersion((l = e.walletConnectVersion) != null ? l : 1), !i.state.isStandalone) {\n      const c = p.client().getDefaultChain();\n      i.setSelectedChain(c), i.setChains(p.client().chains);\n    }\n\n    e.defaultChain && i.setSelectedChain(e.defaultChain), d.setWeb3ModalVersionInStorage(), Object.assign(b, e);\n  }\n\n},\n      W = \"https://explorer-api.walletconnect.com\";\n\nfunction D(e) {\n  const t = Object.fromEntries(Object.entries(e).filter(_ref => {\n    let [n, a] = _ref;\n    return typeof a < \"u\" && a !== null && a !== \"\";\n  }).map(_ref2 => {\n    let [n, a] = _ref2;\n    return [n, a.toString()];\n  }));\n  return new URLSearchParams(t).toString();\n}\n\nconst I = {\n  async fetchWallets(e, t) {\n    const n = D(t),\n          a = `${W}/v3/wallets?projectId=${e}&${n}`;\n    return (await fetch(a)).json();\n  },\n\n  formatImageUrl(e, t) {\n    return `${W}/v3/logo/lg/${t}?projectId=${e}`;\n  }\n\n},\n      h = u({\n  wallets: {\n    listings: [],\n    total: 0,\n    page: 1\n  },\n  search: {\n    listings: [],\n    total: 0,\n    page: 1\n  },\n  previewWallets: [],\n  recomendedWallets: []\n});\n\nfunction y() {\n  const {\n    projectId: e\n  } = S.state;\n  if (!e) throw new Error(\"projectId is required to work with explorer api\");\n  return e;\n}\n\nconst _ = {\n  state: h,\n\n  async getPreviewWallets(e) {\n    const {\n      listings: t\n    } = await I.fetchWallets(y(), e);\n    return h.previewWallets = Object.values(t), h.previewWallets;\n  },\n\n  async getRecomendedWallets() {\n    const {\n      listings: e\n    } = await I.fetchWallets(y(), {\n      page: 1,\n      entries: 6\n    });\n    h.recomendedWallets = Object.values(e);\n  },\n\n  async getPaginatedWallets(e) {\n    const {\n      page: t,\n      search: n\n    } = e,\n          {\n      listings: a,\n      total: l\n    } = await I.fetchWallets(y(), e),\n          c = Object.values(a),\n          v = n ? \"search\" : \"wallets\";\n    return h[v] = {\n      listings: [...h[v].listings, ...c],\n      total: l,\n      page: t ?? 1\n    }, {\n      listings: c,\n      total: l\n    };\n  },\n\n  getImageUrl(e) {\n    return I.formatImageUrl(y(), e);\n  },\n\n  resetSearch() {\n    h.search = {\n      listings: [],\n      total: 0,\n      page: 1\n    };\n  }\n\n},\n      r = u({\n  history: [\"ConnectWallet\"],\n  view: \"ConnectWallet\",\n  data: void 0\n}),\n      g = {\n  state: r,\n\n  subscribe(e) {\n    return f(r, () => e(r));\n  },\n\n  push(e, t) {\n    e !== r.view && (r.view = e, t && (r.data = t), r.history.push(e));\n  },\n\n  replace(e) {\n    r.view = e, r.history = [e];\n  },\n\n  goBack() {\n    if (r.history.length > 1) {\n      r.history.pop();\n      const [e] = r.history.slice(-1);\n      r.view = e;\n    }\n  }\n\n},\n      m = u({\n  open: !1\n}),\n      x = {\n  state: m,\n\n  subscribe(e) {\n    return f(m, () => e(m));\n  },\n\n  async open(e) {\n    return new Promise(t => {\n      const {\n        isStandalone: n,\n        isUiLoaded: a,\n        isDataLoaded: l\n      } = i.state,\n            {\n        isConnected: c\n      } = A.state,\n            {\n        enableNetworkView: v\n      } = S.state;\n      if (n ? (i.setStandaloneUri(e?.uri), i.setStandaloneChains(e?.standaloneChains), g.replace(\"ConnectWallet\")) : e != null && e.route ? g.replace(e.route) : c ? g.replace(\"Account\") : v ? g.replace(\"SelectNetwork\") : g.replace(\"ConnectWallet\"), a && l) m.open = !0, t();else {\n        const N = setInterval(() => {\n          i.state.isUiLoaded && i.state.isDataLoaded && (clearInterval(N), m.open = !0, t());\n        }, 200);\n      }\n    });\n  },\n\n  close() {\n    m.open = !1;\n  }\n\n};\n\nvar P = Object.defineProperty,\n    E = Object.getOwnPropertySymbols,\n    j = Object.prototype.hasOwnProperty,\n    k = Object.prototype.propertyIsEnumerable,\n    O = (e, t, n) => t in e ? P(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: n\n}) : e[t] = n,\n    M = (e, t) => {\n  for (var n in t || (t = {})) j.call(t, n) && O(e, n, t[n]);\n\n  if (E) for (var n of E(t)) k.call(t, n) && O(e, n, t[n]);\n  return e;\n};\n\nfunction $() {\n  return typeof matchMedia < \"u\" && matchMedia(\"(prefers-color-scheme: dark)\").matches;\n}\n\nconst w = u({\n  themeMode: $() ? \"dark\" : \"light\"\n}),\n      B = {\n  state: w,\n\n  subscribe(e) {\n    return f(w, () => e(w));\n  },\n\n  setThemeConfig(e) {\n    const {\n      themeMode: t,\n      themeVariables: n\n    } = e;\n    t && (w.themeMode = t), n && (w.themeVariables = M({}, n));\n  }\n\n},\n      C = u({\n  open: !1,\n  message: \"\",\n  variant: \"success\"\n}),\n      H = {\n  state: C,\n\n  subscribe(e) {\n    return f(C, () => e(C));\n  },\n\n  openToast(e, t) {\n    C.open = !0, C.message = e, C.variant = t;\n  },\n\n  closeToast() {\n    C.open = !1;\n  }\n\n};\ntypeof window < \"u\" && (window.Buffer || (window.Buffer = U), window.global || (window.global = window), window.process || (window.process = {\n  env: {}\n}));\nexport { A as AccountCtrl, p as ClientCtrl, S as ConfigCtrl, d as CoreUtil, _ as ExplorerCtrl, x as ModalCtrl, i as OptionsCtrl, g as RouterCtrl, B as ThemeCtrl, H as ToastCtrl }; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}