{"ast":null,"code":"import { ChaCha20Poly1305 as J } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as Ye } from \"@stablelib/hkdf\";\nimport { randomBytes as Q } from \"@stablelib/random\";\nimport { SHA256 as We, hash as Z } from \"@stablelib/sha256\";\nimport * as X from \"@stablelib/x25519\";\nimport { toString as l, fromString as f, concat as ee } from \"uint8arrays\";\nimport { detect as Je } from \"detect-browser\";\nimport { toMiliseconds as D, FIVE_MINUTES as ne, fromMiliseconds as Qe } from \"@walletconnect/time\";\nimport { getDocument as Ze, getNavigator as te, getLocation as re } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Xe } from \"@walletconnect/window-metadata\";\nimport * as P from \"query-string\";\nimport { RELAY_JSONRPC as en } from \"@walletconnect/relay-api\";\nconst T = \":\";\n\nfunction oe(e) {\n  const [n, t] = e.split(T);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\n\nfunction se(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(T);\n}\n\nfunction j(e) {\n  const [n, t, r] = e.split(T);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\n\nfunction ie(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(T);\n}\n\nfunction V(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\n\nfunction ce(e) {\n  const {\n    address: n\n  } = j(e);\n  return n;\n}\n\nfunction ae(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = j(e);\n  return se({\n    namespace: n,\n    reference: t\n  });\n}\n\nfunction nn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = oe(n);\n  return ie({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\n\nfunction tn(e) {\n  return V(e, ce);\n}\n\nfunction ue(e) {\n  return V(e, ae);\n}\n\nfunction rn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\n\nfunction on(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ue(o.accounts));\n  }), t;\n}\n\nfunction sn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...R(r, o));\n  }), t;\n}\n\nfunction R(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\n\nconst U = e => e?.split(\":\"),\n      de = e => {\n  const n = e && U(e);\n  if (n) return n[3];\n},\n      cn = e => {\n  const n = e && U(e);\n  if (n) return n[2] + \":\" + n[3];\n},\n      le = e => {\n  const n = e && U(e);\n  if (n) return n.pop();\n},\n      an = (e, n) => {\n  const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n        r = le(n),\n        o = e.statement,\n        s = `URI: ${e.aud}`,\n        i = `Version: ${e.version}`,\n        a = `Chain ID: ${de(n)}`,\n        p = `Nonce: ${e.nonce}`,\n        y = `Issued At: ${e.iat}`,\n        m = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(c => `- ${c}`).join(`\n`)}` : void 0;\n  return [t, r, \"\", o, \"\", s, i, a, p, y, m].filter(c => c != null).join(`\n`);\n},\n      M = \"base10\",\n      u = \"base16\",\n      A = \"base64pad\",\n      _ = \"utf8\",\n      K = 0,\n      b = 1,\n      un = 0,\n      fe = 1,\n      k = 12,\n      L = 32;\n\nfunction dn() {\n  const e = X.generateKeyPair();\n  return {\n    privateKey: l(e.secretKey, u),\n    publicKey: l(e.publicKey, u)\n  };\n}\n\nfunction ln() {\n  const e = Q(L);\n  return l(e, u);\n}\n\nfunction fn(e, n) {\n  const t = X.sharedKey(f(e, u), f(n, u)),\n        r = new Ye(We, t).expand(L);\n  return l(r, u);\n}\n\nfunction pn(e) {\n  const n = Z(f(e, u));\n  return l(n, u);\n}\n\nfunction mn(e) {\n  const n = Z(f(e, _));\n  return l(n, u);\n}\n\nfunction pe(e) {\n  return f(`${e}`, M);\n}\n\nfunction S(e) {\n  return Number(l(e, M));\n}\n\nfunction yn(e) {\n  const n = pe(typeof e.type < \"u\" ? e.type : K);\n  if (S(n) === b && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? f(e.senderPublicKey, u) : void 0,\n        r = typeof e.iv < \"u\" ? f(e.iv, u) : Q(k),\n        o = new J(f(e.symKey, u)).seal(r, f(e.message, _));\n  return me({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\n\nfunction En(e) {\n  const n = new J(f(e.symKey, u)),\n        {\n    sealed: t,\n    iv: r\n  } = F(e.encoded),\n        o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return l(o, _);\n}\n\nfunction me(e) {\n  if (S(e.type) === b) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return l(ee([e.type, e.senderPublicKey, e.iv, e.sealed]), A);\n  }\n\n  return l(ee([e.type, e.iv, e.sealed]), A);\n}\n\nfunction F(e) {\n  const n = f(e, A),\n        t = n.slice(un, fe),\n        r = fe;\n\n  if (S(t) === b) {\n    const a = r + L,\n          p = a + k,\n          y = n.slice(r, a),\n          m = n.slice(a, p),\n          c = n.slice(p);\n    return {\n      type: t,\n      sealed: c,\n      iv: m,\n      senderPublicKey: y\n    };\n  }\n\n  const o = r + k,\n        s = n.slice(r, o),\n        i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\n\nfunction gn(e, n) {\n  const t = F(e);\n  return ye({\n    type: S(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? l(t.senderPublicKey, u) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\n\nfunction ye(e) {\n  const n = e?.type || K;\n\n  if (n === b) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\n\nfunction hn(e) {\n  return e.type === b && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\n\nvar Nn = Object.defineProperty,\n    Ee = Object.getOwnPropertySymbols,\n    vn = Object.prototype.hasOwnProperty,\n    bn = Object.prototype.propertyIsEnumerable,\n    ge = (e, n, t) => n in e ? Nn(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    he = (e, n) => {\n  for (var t in n || (n = {})) vn.call(n, t) && ge(e, t, n[t]);\n\n  if (Ee) for (var t of Ee(n)) bn.call(n, t) && ge(e, t, n[t]);\n  return e;\n};\n\nconst Ne = \"ReactNative\",\n      O = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\"\n},\n      C = \" \",\n      On = \":\",\n      ve = \"/\",\n      x = 2,\n      Sn = 1e3,\n      be = \"js\";\n\nfunction H() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\n\nfunction Oe() {\n  return !Ze() && !!te() && navigator.product === Ne;\n}\n\nfunction Se() {\n  return !H() && !!te();\n}\n\nfunction q() {\n  return Oe() ? O.reactNative : H() ? O.node : Se() ? O.browser : O.unknown;\n}\n\nfunction Ie(e, n) {\n  let t = P.parse(e);\n  return t = he(he({}, t), n), e = P.stringify(t), e;\n}\n\nfunction In() {\n  return Xe() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\n\nfunction Pn(e, n) {\n  var t;\n  const r = q(),\n        o = {\n    protocol: e,\n    version: n,\n    env: r\n  };\n  return r === \"browser\" && (o.host = ((t = re()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\n\nfunction Pe() {\n  const e = Je();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\n\nfunction Te() {\n  var e;\n  const n = q();\n  return n === O.browser ? [n, ((e = re()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\n\nfunction Re(e, n, t) {\n  const r = Pe(),\n        o = Te();\n  return [[e, n].join(\"-\"), [be, t].join(\"-\"), r, o].join(\"/\");\n}\n\nfunction Tn(_ref) {\n  let {\n    protocol: e,\n    version: n,\n    relayUrl: t,\n    sdkVersion: r,\n    auth: o,\n    projectId: s,\n    useOnCloseEvent: i\n  } = _ref;\n  const a = t.split(\"?\"),\n        p = Re(e, n, r),\n        y = {\n    auth: o,\n    ua: p,\n    projectId: s,\n    useOnCloseEvent: i || void 0\n  },\n        m = Ie(a[1] || \"\", y);\n  return a[0] + \"?\" + m;\n}\n\nfunction Rn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\n\nfunction Un(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\n\nfunction Ue(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return Ae(e.split(ve), n);\n}\n\nfunction An(e) {\n  return Ue(e).join(C);\n}\n\nfunction g(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\n\nfunction Ae(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return e.slice(Math.max(e.length - n, 0));\n}\n\nfunction _n(e) {\n  return Object.fromEntries(e.entries());\n}\n\nfunction Cn(e) {\n  return new Map(Object.entries(e));\n}\n\nfunction wn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\n\nconst $n = e => e;\n\nfunction _e(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\n\nfunction Dn(e) {\n  return e.split(C).map(n => _e(n)).join(C);\n}\n\nfunction jn() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ne;\n  let n = arguments.length > 1 ? arguments[1] : undefined;\n  const t = D(e || ne);\n  let r, o, s;\n  return {\n    resolve: i => {\n      s && r && (clearTimeout(s), r(i));\n    },\n    reject: i => {\n      s && o && (clearTimeout(s), o(i));\n    },\n    done: () => new Promise((i, a) => {\n      s = setTimeout(() => {\n        a(new Error(n));\n      }, t), r = i, o = a;\n    })\n  };\n}\n\nfunction Vn(e, n) {\n  return new Promise(async (t, r) => {\n    const o = setTimeout(() => r(), n),\n          s = await e;\n    clearTimeout(o), t(s);\n  });\n}\n\nfunction B(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\n\nfunction Mn(e) {\n  return B(\"topic\", e);\n}\n\nfunction Kn(e) {\n  return B(\"id\", e);\n}\n\nfunction kn(e) {\n  const [n, t] = e.split(\":\"),\n        r = {\n    id: void 0,\n    topic: void 0\n  };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\n\nfunction Ln(e, n) {\n  return Qe((n || Date.now()) + D(e));\n}\n\nfunction Fn(e) {\n  return Date.now() >= D(e);\n}\n\nfunction xn(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\n\nconst Ce = \"irn\";\n\nfunction Hn(e) {\n  return e?.relay || {\n    protocol: Ce\n  };\n}\n\nfunction qn(e) {\n  const n = en[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\n\nvar Bn = Object.defineProperty,\n    we = Object.getOwnPropertySymbols,\n    Gn = Object.prototype.hasOwnProperty,\n    zn = Object.prototype.propertyIsEnumerable,\n    $e = (e, n, t) => n in e ? Bn(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    Yn = (e, n) => {\n  for (var t in n || (n = {})) Gn.call(n, t) && $e(e, t, n[t]);\n\n  if (we) for (var t of we(n)) zn.call(n, t) && $e(e, t, n[t]);\n  return e;\n};\n\nfunction De(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = {},\n        r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n            i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\n\nfunction Wn(e) {\n  const n = e.indexOf(\":\"),\n        t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n        r = e.substring(0, n),\n        o = e.substring(n + 1, t).split(\"@\"),\n        s = typeof t < \"u\" ? e.substring(t) : \"\",\n        i = P.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: De(i)\n  };\n}\n\nfunction je(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = \"relay\",\n        r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\n\nfunction Jn(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + P.stringify(Yn({\n    symKey: e.symKey\n  }, je(e.relay)));\n}\n\nfunction N(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\n\nfunction Ve(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...N(t.accounts));\n  }), n;\n}\n\nfunction Me(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    N(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\n\nfunction Ke(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    N(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\n\nfunction Qn(e, n) {\n  const t = Be(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n\n  return r;\n}\n\nconst Zn = {\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005\n  },\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004\n  },\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5e3\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104\n  },\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6e3\n  },\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7e3\n  },\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001\n  }\n},\n      Xn = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9\n  }\n};\n\nfunction E(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Xn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\n\nfunction v(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Zn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\n\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\n\nfunction G(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\n\nfunction h(e) {\n  return typeof e > \"u\";\n}\n\nfunction d(e, n) {\n  return n && h(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\n\nfunction w(e, n) {\n  return n && h(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\n\nfunction et(e, n) {\n  const {\n    requiredNamespaces: t\n  } = n,\n        r = Object.keys(e.namespaces),\n        o = Object.keys(t);\n  let s = !0;\n  return g(o, r) ? (r.forEach(i => {\n    const {\n      accounts: a,\n      methods: p,\n      events: y\n    } = e.namespaces[i],\n          m = N(a),\n          c = t[i];\n    (!g(R(i, c), m) || !g(c.methods, p) || !g(c.events, y)) && (s = !1);\n  }), s) : !1;\n}\n\nfunction $(e) {\n  return d(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\n\nfunction ke(e) {\n  if (d(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && $(t);\n    }\n  }\n\n  return !1;\n}\n\nfunction nt(e) {\n  if (d(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\n\nfunction tt(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\n\nfunction rt(e) {\n  return e?.topic;\n}\n\nfunction ot(e, n) {\n  let t = null;\n  return d(e?.publicKey, !1) || (t = E(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\n\nfunction z(e) {\n  let n = !0;\n  return I(e) ? e.length && (n = e.every(t => d(t, !1))) : n = !1, n;\n}\n\nfunction Le(e, n, t) {\n  let r = null;\n  return I(n) ? n.forEach(o => {\n    r || (!$(o) || !o.includes(e)) && (r = v(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = v(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\n\nfunction Fe(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(_ref2 => {\n    let [r, o] = _ref2;\n    if (t) return;\n    const s = Le(r, R(r, o), `${n} requiredNamespace`);\n    s && (t = s);\n  }), t;\n}\n\nfunction xe(e, n) {\n  let t = null;\n  return I(e) ? e.forEach(r => {\n    t || ke(r) || (t = v(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = v(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\n\nfunction He(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = xe(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\n\nfunction qe(e, n) {\n  let t = null;\n  return z(e?.methods) ? z(e?.events) || (t = v(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = v(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\n\nfunction Y(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = qe(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\n\nfunction st(e, n, t) {\n  let r = null;\n\n  if (e && G(e)) {\n    const o = Y(e, n);\n    o && (r = o);\n    const s = Fe(e, n);\n    s && (r = s);\n  } else r = E(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n\n  return r;\n}\n\nfunction Be(e, n) {\n  let t = null;\n\n  if (e && G(e)) {\n    const r = Y(e, n);\n    r && (t = r);\n    const o = He(e, n);\n    o && (t = o);\n  } else t = E(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n\n  return t;\n}\n\nfunction Ge(e) {\n  return d(e.protocol, !0);\n}\n\nfunction it(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(r => {\n    t = Ge(r);\n  }), t;\n}\n\nfunction ct(e) {\n  return typeof e == \"number\";\n}\n\nfunction at(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\n\nfunction ut(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !w(e.code, !1) || !e.message || !d(e.message, !1));\n}\n\nfunction dt(e) {\n  return !(h(e) || !d(e.method, !1));\n}\n\nfunction lt(e) {\n  return !(h(e) || h(e.result) && h(e.error) || !w(e.id, !1) || !d(e.jsonrpc, !1));\n}\n\nfunction ft(e) {\n  return !(h(e) || !d(e.name, !1));\n}\n\nfunction pt(e, n) {\n  return !(!$(n) || !Ve(e).includes(n));\n}\n\nfunction mt(e, n, t) {\n  return d(t, !1) ? Me(e, n).includes(t) : !1;\n}\n\nfunction yt(e, n, t) {\n  return d(t, !1) ? Ke(e, n).includes(t) : !1;\n}\n\nfunction Et(e, n, t) {\n  let r = null;\n  const o = gt(e),\n        s = ht(n),\n        i = Object.keys(o),\n        a = Object.keys(s),\n        p = ze(Object.keys(e)),\n        y = ze(Object.keys(n)),\n        m = p.filter(c => !y.includes(c));\n  return m.length && (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${m.toString()}\n      Received: ${Object.keys(n).toString()}`)), g(i, a) || (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${a.toString()}`)), Object.keys(n).forEach(c => {\n    if (!c.includes(\":\") || r) return;\n    const W = N(n[c].accounts);\n    W.includes(c) || (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${c}\n        Required: ${c}\n        Approved: ${W.toString()}`));\n  }), i.forEach(c => {\n    r || (g(o[c].methods, s[c].methods) ? g(o[c].events, s[c].events) || (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${c}`)) : r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${c}`));\n  }), r;\n}\n\nfunction gt(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\n\nfunction ze(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\n\nfunction ht(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = N(e[t].accounts);\n      r?.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\n\nfunction Nt(e, n) {\n  return w(e, !1) && e <= n.max && e >= n.min;\n}\n\nexport { M as BASE10, u as BASE16, A as BASE64, On as COLON, x as DEFAULT_DEPTH, C as EMPTY_SPACE, O as ENV_MAP, Sn as ONE_THOUSAND, Ne as REACT_NATIVE_PRODUCT, Ce as RELAYER_DEFAULT_PROTOCOL, be as SDK_TYPE, ve as SLASH, K as TYPE_0, b as TYPE_1, _ as UTF8, Ie as appendToQueryString, Un as assertType, Ln as calcExpiry, Dn as capitalize, _e as capitalizeWord, jn as createDelayedPromise, Vn as createExpiringPromise, S as decodeTypeByte, En as decrypt, fn as deriveSymKey, F as deserialize, pe as encodeTypeByte, yn as encrypt, xn as engineEvent, $n as enumify, ie as formatAccountId, nn as formatAccountWithChain, se as formatChainId, B as formatExpirerTarget, Kn as formatIdTarget, an as formatMessage, An as formatMessageContext, je as formatRelayParams, Tn as formatRelayRpcUrl, Mn as formatTopicTarget, Re as formatUA, Jn as formatUri, dn as generateKeyPair, ln as generateRandomBytes32, N as getAccountsChains, rn as getAccountsFromNamespaces, ce as getAddressFromAccount, tn as getAddressesFromAccounts, In as getAppMetadata, ae as getChainFromAccount, ue as getChainsFromAccounts, R as getChainsFromNamespace, on as getChainsFromNamespaces, sn as getChainsFromRequiredNamespaces, le as getDidAddress, U as getDidAddressSegments, de as getDidChainId, q as getEnvironment, Rn as getHttpUrl, E as getInternalError, Te as getJavascriptID, Pe as getJavascriptOS, Ae as getLastItems, cn as getNamespacedDidChainId, Ve as getNamespacesChains, Ke as getNamespacesEventsForChainId, Me as getNamespacesMethodsForChainId, Pn as getRelayClientMetadata, qn as getRelayProtocolApi, Hn as getRelayProtocolName, Qn as getRequiredNamespacesFromNamespaces, v as getSdkError, V as getUniqueValues, g as hasOverlap, pn as hashKey, mn as hashMessage, Se as isBrowser, Et as isConformingNamespaces, Fn as isExpired, H as isNode, tt as isProposalStruct, Oe as isReactNative, et as isSessionCompatible, rt as isSessionStruct, hn as isTypeOneEnvelope, h as isUndefined, ke as isValidAccountId, xe as isValidAccounts, qe as isValidActions, I as isValidArray, $ as isValidChainId, Le as isValidChains, ot as isValidController, ut as isValidErrorReason, ft as isValidEvent, ct as isValidId, He as isValidNamespaceAccounts, Y as isValidNamespaceActions, Fe as isValidNamespaceChains, z as isValidNamespaceMethodsOrEvents, Be as isValidNamespaces, pt as isValidNamespacesChainId, yt as isValidNamespacesEvent, mt as isValidNamespacesRequest, w as isValidNumber, G as isValidObject, at as isValidParams, Ge as isValidRelay, it as isValidRelays, dt as isValidRequest, Nt as isValidRequestExpiry, st as isValidRequiredNamespaces, lt as isValidResponse, d as isValidString, nt as isValidUrl, wn as mapEntries, _n as mapToObj, Cn as objToMap, j as parseAccountId, oe as parseChainId, Ue as parseContextNames, kn as parseExpirerTarget, De as parseRelayParams, Wn as parseUri, me as serialize, gn as validateDecoding, ye as validateEncoding }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}