{"ast":null,"code":"import { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-eea39a9a.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { C as Connector, b as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError, a as ChainNotConfiguredError, A as AddChainError, S as SwitchChainError } from '../../../../dist/errors-e1a2656b.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport '../../../../dist/checkPrivateRedeclaration-3aaaa21d.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nfunction getInjectedName(ethereum) {\n  if (!ethereum) {\n    return \"Injected\";\n  }\n\n  const getName = provider => {\n    if (provider.isAvalanche) {\n      return \"Core Wallet\";\n    }\n\n    if (provider.isBitKeep) {\n      return \"BitKeep\";\n    }\n\n    if (provider.isBraveWallet) {\n      return \"Brave Wallet\";\n    }\n\n    if (provider.isCoinbaseWallet) {\n      return \"Coinbase Wallet\";\n    }\n\n    if (provider.isExodus) {\n      return \"Exodus\";\n    }\n\n    if (provider.isFrame) {\n      return \"Frame\";\n    }\n\n    if (provider.isKuCoinWallet) {\n      return \"KuCoin Wallet\";\n    }\n\n    if (provider.isMathWallet) {\n      return \"MathWallet\";\n    }\n\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {\n      return \"1inch Wallet\";\n    }\n\n    if (provider.isOpera) {\n      return \"Opera\";\n    }\n\n    if (provider.isPortal) {\n      return \"Ripio Portal\";\n    }\n\n    if (provider.isTally) {\n      return \"Tally\";\n    }\n\n    if (provider.isTokenPocket) {\n      return \"TokenPocket\";\n    }\n\n    if (provider.isTokenary) {\n      return \"Tokenary\";\n    }\n\n    if (provider.isTrust || provider.isTrustWallet) {\n      return \"Trust Wallet\";\n    }\n\n    if (provider.isMetaMask) {\n      return \"MetaMask\";\n    }\n  }; // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n\n\n  if (ethereum.providers?.length) {\n    // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n    const nameSet = new Set();\n    let unknownCount = 1;\n\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n\n      nameSet.add(name);\n    }\n\n    const names = [...nameSet];\n\n    if (names.length) {\n      return names;\n    }\n\n    return names[0] ?? \"Injected\";\n  }\n\n  return getName(ethereum) ?? \"Injected\";\n}\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchingChains = /*#__PURE__*/new WeakMap();\n\nclass InjectedConnector extends Connector {\n  /**\n   * Name of the injected connector\n   */\n\n  /**\n   * Whether the connector is ready to be used\n   *\n   * `true` if the injected provider is found\n   */\n  constructor(arg) {\n    const defaultOptions = {\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider: () => {\n        if (assertWindowEthereum(window)) {\n          return window.ethereum;\n        }\n      }\n    };\n    const options = { ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options\n    });\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ready\", void 0);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _switchingChains, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"connectorStorage\", void 0);\n\n    _defineProperty(this, \"shimDisconnectKey\", \"injected.shimDisconnect\");\n    /**\n     * handles the `accountsChanged` event from the provider\n     * * emits `change` event if connected to a different account\n     * * emits `disconnect` event if no accounts available\n     */\n\n\n    _defineProperty(this, \"onAccountsChanged\", async accounts => {\n      if (accounts.length === 0) {\n        await this.onDisconnect();\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n    /**\n     * handles the `chainChanged` event from the provider\n     * * emits `change` event if connected to a different chain\n     */\n\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    /**\n     * handles the `disconnect` event from the provider\n     * * emits `disconnect` event\n     */\n\n\n    _defineProperty(this, \"onDisconnect\", async () => {\n      // We need this as MetaMask can emit the \"disconnect\" event\n      // upon switching chains. This workaround ensures that the\n      // user currently isn't in the process of switching chains.\n      if (this.options.shimChainChangedDisconnect && _classPrivateFieldGet(this, _switchingChains)) {\n        _classPrivateFieldSet(this, _switchingChains, false);\n\n        return;\n      }\n\n      this.emit(\"disconnect\"); // Remove `shimDisconnect` => it signals that wallet is disconnected\n\n      if (this.options.shimDisconnect) {\n        await this.connectorStorage.removeItem(this.shimDisconnectKey);\n      }\n    });\n\n    const provider = options.getProvider(); // set the name of the connector\n\n    if (typeof options.name === \"string\") {\n      // if name is given, use that\n      this.name = options.name;\n    } else if (provider) {\n      // if injected provider is detected, get name from it\n      const detectedName = getInjectedName(provider);\n\n      if (options.name) {\n        this.name = options.name(detectedName);\n      } else {\n        if (typeof detectedName === \"string\") {\n          this.name = detectedName;\n        } else {\n          this.name = detectedName[0];\n        }\n      }\n    } else {\n      // else default to \"Injected\"\n      this.name = \"Injected\";\n    }\n\n    this.id = \"injected\";\n    this.ready = !!provider;\n    this.connectorStorage = arg.connectorStorage;\n  }\n  /**\n   * * Connect to the injected provider\n   * * switch to the given chain if `chainId` is specified as an argument\n   */\n\n\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      const provider = await this.getProvider();\n\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n\n      this.setupListeners(); // emit \"connecting\" event\n\n      this.emit(\"message\", {\n        type: \"connecting\"\n      }); // request account addresses from injected provider\n\n      const accountAddresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      }); // get the first account address\n\n      const firstAccountAddress = utils.getAddress(accountAddresses[0]); // Switch to given chain if a chainId is specified\n\n      let connectedChainId = await this.getChainId(); // Check if currently connected chain is unsupported\n      // chainId is considered unsupported if chainId is not in the list of this.chains array\n\n      let isUnsupported = this.isChainUnsupported(connectedChainId); // if chainId is specified and it is not the same as the currently connected chain\n\n      if (options.chainId && connectedChainId !== options.chainId) {\n        // switch to the given chain\n        try {\n          await this.switchChain(options.chainId); // recalculate connectedChainId and isUnsupported\n\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id: ${options.chainId}`, e);\n        }\n      } // if shimDisconnect is enabled\n\n\n      if (this.options.shimDisconnect) {\n        // add the shim shimDisconnectKey => it signals that wallet is connected\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n\n      const connectionInfo = {\n        account: firstAccountAddress,\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * disconnect from the injected provider\n   */\n\n\n  async disconnect() {\n    // perform cleanup\n    const provider = await this.getProvider();\n\n    if (!provider?.removeListener) {\n      return;\n    }\n\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect); // if shimDisconnect is enabled\n\n    if (this.options.shimDisconnect) {\n      // Remove the shimDisconnectKey => it signals that wallet is disconnected\n      await this.connectorStorage.removeItem(this.shimDisconnectKey);\n    }\n  }\n  /**\n   * @returns The first account address from the injected provider\n   */\n\n\n  async getAccount() {\n    const provider = await this.getProvider();\n\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    }); // return checksum address\n    // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress\n\n    return utils.getAddress(accounts[0]);\n  }\n  /**\n   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`\n   */\n\n\n  async getChainId() {\n    const provider = await this.getProvider();\n\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    return provider.request({\n      method: \"eth_chainId\"\n    }).then(normalizeChainId);\n  }\n  /**\n   * get the injected provider\n   */\n\n\n  async getProvider() {\n    const provider = this.options.getProvider();\n\n    if (provider) {\n      _classPrivateFieldSet(this, _provider, provider); // setting listeners\n\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n  /**\n   * get a `signer` for given `chainId`\n   */\n\n\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]); // ethers.providers.Web3Provider\n\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n  /**\n   *\n   * @returns `true` if the connector is connected and address is available, else `false`\n   */\n\n\n  async isAuthorized() {\n    try {\n      // `false` if connector is disconnected\n      if (this.options.shimDisconnect && // If shim does not exist in storage, wallet is disconnected\n      !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        return false;\n      }\n\n      const provider = await this.getProvider();\n\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      } // `false` if no account address available, else `true`\n\n\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      // `false` if any error thrown\n      return false;\n    }\n  }\n  /**\n   * switch to given chain\n   */\n\n\n  async switchChain(chainId) {\n    // set switchingChains to true to different switching chain from disconnect\n    if (this.options.shimChainChangedDisconnect) {\n      _classPrivateFieldSet(this, _switchingChains, true);\n    }\n\n    const provider = await this.getProvider();\n\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n\n    const chainIdHex = utils.hexValue(chainId);\n\n    try {\n      // request provider to switch to given chainIdHex\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n\n      if (chain) {\n        return chain;\n      }\n\n      return {\n        chainId: chainId,\n        name: `Chain ${chainIdHex}`,\n        slug: `${chainIdHex}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpc: [\"\"],\n        chain: \"\",\n        shortName: \"\",\n        testnet: true\n      };\n    } catch (error) {\n      // if could not switch to given chainIdHex\n      // if tried to connect to a chain that is not configured\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n\n      if (!chain) {\n        throw new ChainNotConfiguredError({\n          chainId,\n          connectorId: this.id\n        });\n      } // if chain is not added to provider\n\n\n      if (error.code === 4902 || // Unwrapping for MetaMask Mobile\n      // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n      error?.data?.originalError?.code === 4902) {\n        try {\n          // request provider to add chain\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [{\n              chainId: chainIdHex,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: chain.rpc,\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          // if user rejects request to add chain\n          if (this.isUserRejectedRequestError(addError)) {\n            throw new UserRejectedRequestError(error);\n          } // else other error\n\n\n          throw new AddChainError();\n        }\n      }\n\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      throw new SwitchChainError(error);\n    }\n  }\n\n  async setupListeners() {\n    const provider = await this.getProvider();\n\n    if (provider.on) {\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n    }\n  }\n\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n\n}\n\nexport { InjectedConnector };","map":null,"metadata":{},"sourceType":"module"}