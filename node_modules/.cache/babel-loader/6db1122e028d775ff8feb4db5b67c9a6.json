{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCreateCallContract = exports.getSignMessageLibContract = exports.getMultiSendCallOnlyContract = exports.getMultiSendContract = exports.getCompatibilityFallbackHandlerContract = exports.getProxyFactoryContract = exports.getSafeContract = exports.getCreateCallContractDeployment = exports.getSignMessageLibContractDeployment = exports.getSafeProxyFactoryContractDeployment = exports.getMultiSendContractDeployment = exports.getMultiSendCallOnlyContractDeployment = exports.getCompatibilityFallbackHandlerContractDeployment = exports.getSafeContractDeployment = void 0;\n\nconst safe_deployments_1 = require(\"@safe-global/safe-deployments\");\n\nconst config_1 = require(\"./config\");\n\nfunction getSafeContractDeployment(safeVersion, chainId) {\n  let isL1SafeMasterCopy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const version = config_1.safeDeploymentsVersions[safeVersion].safeMasterCopyVersion;\n  const filters = {\n    version,\n    network: chainId.toString(),\n    released: true\n  };\n\n  if (config_1.safeDeploymentsL1ChainIds.includes(chainId) || isL1SafeMasterCopy) {\n    return (0, safe_deployments_1.getSafeSingletonDeployment)(filters);\n  }\n\n  return (0, safe_deployments_1.getSafeL2SingletonDeployment)(filters);\n}\n\nexports.getSafeContractDeployment = getSafeContractDeployment;\n\nfunction getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId) {\n  const version = config_1.safeDeploymentsVersions[safeVersion].compatibilityFallbackHandler;\n  return (0, safe_deployments_1.getCompatibilityFallbackHandlerDeployment)({\n    version,\n    network: chainId.toString(),\n    released: true\n  });\n}\n\nexports.getCompatibilityFallbackHandlerContractDeployment = getCompatibilityFallbackHandlerContractDeployment;\n\nfunction getMultiSendCallOnlyContractDeployment(safeVersion, chainId) {\n  const version = config_1.safeDeploymentsVersions[safeVersion].multiSendCallOnlyVersion;\n  return (0, safe_deployments_1.getMultiSendCallOnlyDeployment)({\n    version,\n    network: chainId.toString(),\n    released: true\n  });\n}\n\nexports.getMultiSendCallOnlyContractDeployment = getMultiSendCallOnlyContractDeployment;\n\nfunction getMultiSendContractDeployment(safeVersion, chainId) {\n  const version = config_1.safeDeploymentsVersions[safeVersion].multiSendVersion;\n  return (0, safe_deployments_1.getMultiSendDeployment)({\n    version,\n    network: chainId.toString(),\n    released: true\n  });\n}\n\nexports.getMultiSendContractDeployment = getMultiSendContractDeployment;\n\nfunction getSafeProxyFactoryContractDeployment(safeVersion, chainId) {\n  const version = config_1.safeDeploymentsVersions[safeVersion].safeProxyFactoryVersion;\n  return (0, safe_deployments_1.getProxyFactoryDeployment)({\n    version,\n    network: chainId.toString(),\n    released: true\n  });\n}\n\nexports.getSafeProxyFactoryContractDeployment = getSafeProxyFactoryContractDeployment;\n\nfunction getSignMessageLibContractDeployment(safeVersion, chainId) {\n  const version = config_1.safeDeploymentsVersions[safeVersion].signMessageLibVersion;\n  return (0, safe_deployments_1.getSignMessageLibDeployment)({\n    version,\n    network: chainId.toString(),\n    released: true\n  });\n}\n\nexports.getSignMessageLibContractDeployment = getSignMessageLibContractDeployment;\n\nfunction getCreateCallContractDeployment(safeVersion, chainId) {\n  const version = config_1.safeDeploymentsVersions[safeVersion].createCallVersion;\n  return (0, safe_deployments_1.getCreateCallDeployment)({\n    version,\n    network: chainId.toString(),\n    released: true\n  });\n}\n\nexports.getCreateCallContractDeployment = getCreateCallContractDeployment;\n\nasync function getSafeContract(_ref) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customSafeAddress,\n    isL1SafeMasterCopy,\n    customContracts\n  } = _ref;\n  const singletonDeployment = getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy);\n  const gnosisSafeContract = ethAdapter.getSafeContract({\n    safeVersion,\n    chainId,\n    singletonDeployment,\n    customContractAddress: customSafeAddress !== null && customSafeAddress !== void 0 ? customSafeAddress : customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeMasterCopyAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeMasterCopyAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(gnosisSafeContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('SafeProxy contract is not deployed on the current network');\n  }\n\n  return gnosisSafeContract;\n}\n\nexports.getSafeContract = getSafeContract;\n\nasync function getProxyFactoryContract(_ref2) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customContracts\n  } = _ref2;\n  const proxyFactoryDeployment = getSafeProxyFactoryContractDeployment(safeVersion, chainId);\n  const safeProxyFactoryContract = await ethAdapter.getSafeProxyFactoryContract({\n    safeVersion,\n    chainId,\n    singletonDeployment: proxyFactoryDeployment,\n    customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeProxyFactoryAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeProxyFactoryAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(safeProxyFactoryContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('SafeProxyFactory contract is not deployed on the current network');\n  }\n\n  return safeProxyFactoryContract;\n}\n\nexports.getProxyFactoryContract = getProxyFactoryContract;\n\nasync function getCompatibilityFallbackHandlerContract(_ref3) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customContracts\n  } = _ref3;\n  const fallbackHandlerDeployment = getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId);\n  const fallbackHandlerContract = await ethAdapter.getCompatibilityFallbackHandlerContract({\n    safeVersion,\n    chainId,\n    singletonDeployment: fallbackHandlerDeployment,\n    customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.fallbackHandlerAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.fallbackHandlerAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(fallbackHandlerContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('CompatibilityFallbackHandler contract is not deployed on the current network');\n  }\n\n  return fallbackHandlerContract;\n}\n\nexports.getCompatibilityFallbackHandlerContract = getCompatibilityFallbackHandlerContract;\n\nasync function getMultiSendContract(_ref4) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customContracts\n  } = _ref4;\n  const multiSendDeployment = getMultiSendContractDeployment(safeVersion, chainId);\n  const multiSendContract = await ethAdapter.getMultiSendContract({\n    safeVersion,\n    chainId,\n    singletonDeployment: multiSendDeployment,\n    customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(multiSendContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('MultiSend contract is not deployed on the current network');\n  }\n\n  return multiSendContract;\n}\n\nexports.getMultiSendContract = getMultiSendContract;\n\nasync function getMultiSendCallOnlyContract(_ref5) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customContracts\n  } = _ref5;\n  const multiSendCallOnlyDeployment = getMultiSendCallOnlyContractDeployment(safeVersion, chainId);\n  const multiSendCallOnlyContract = await ethAdapter.getMultiSendCallOnlyContract({\n    safeVersion,\n    chainId,\n    singletonDeployment: multiSendCallOnlyDeployment,\n    customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendCallOnlyAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendCallOnlyAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(multiSendCallOnlyContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('MultiSendCallOnly contract is not deployed on the current network');\n  }\n\n  return multiSendCallOnlyContract;\n}\n\nexports.getMultiSendCallOnlyContract = getMultiSendCallOnlyContract;\n\nasync function getSignMessageLibContract(_ref6) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customContracts\n  } = _ref6;\n  const signMessageLibDeployment = getSignMessageLibContractDeployment(safeVersion, chainId);\n  const signMessageLibContract = await ethAdapter.getSignMessageLibContract({\n    safeVersion,\n    chainId,\n    singletonDeployment: signMessageLibDeployment,\n    customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.signMessageLibAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.signMessageLibAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(signMessageLibContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('SignMessageLib contract is not deployed on the current network');\n  }\n\n  return signMessageLibContract;\n}\n\nexports.getSignMessageLibContract = getSignMessageLibContract;\n\nasync function getCreateCallContract(_ref7) {\n  let {\n    ethAdapter,\n    safeVersion,\n    chainId,\n    customContracts\n  } = _ref7;\n  const createCallDeployment = getCreateCallContractDeployment(safeVersion, chainId);\n  const createCallContract = await ethAdapter.getCreateCallContract({\n    safeVersion,\n    chainId,\n    singletonDeployment: createCallDeployment,\n    customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.createCallAddress,\n    customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.createCallAbi\n  });\n  const isContractDeployed = await ethAdapter.isContractDeployed(createCallContract.getAddress());\n\n  if (!isContractDeployed) {\n    throw new Error('CreateCall contract is not deployed on the current network');\n  }\n\n  return createCallContract;\n}\n\nexports.getCreateCallContract = getCreateCallContract; //# sourceMappingURL=safeDeploymentContracts.js.map","map":null,"metadata":{},"sourceType":"script"}