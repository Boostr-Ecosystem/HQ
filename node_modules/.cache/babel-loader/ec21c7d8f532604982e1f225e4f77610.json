{"ast":null,"code":"var _a, _b, _c, _d, _e;\n\nimport { $getLoadedMaterial, $variantIndices } from '../material.js';\nimport { $correlatedObjects } from '../three-dom-element.js';\nconst $materials = Symbol('materials');\nconst $variantToMaterialMap = Symbol('variantToMaterialMap');\nconst $modelVariants = Symbol('modelVariants');\nconst $mesh = Symbol('mesh');\nexport const $primitives = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $children = Symbol('children');\nexport const $initialMaterialIdx = Symbol('initialMaterialIdx');\nexport const $activeMaterialIdx = Symbol('activeMaterialIdx'); // Defines the base level node methods and data.\n\nexport class Node {\n  constructor(name) {\n    this.name = '';\n    this[_a] = new Array();\n    this.name = name;\n  }\n\n}\n_a = $children; // Represents a primitive in a glTF mesh.\n\nexport class PrimitiveNode extends Node {\n  constructor(mesh, mvMaterials, modelVariants, correlatedSceneGraph) {\n    super(mesh.name); // Maps glTF material index number to a material that this primitive supports.\n\n    this[_b] = new Map(); // Maps variant index to material.\n\n    this[_c] = new Map();\n    this[_d] = 0;\n    this[_e] = 0;\n    this[$mesh] = mesh;\n    const {\n      gltf,\n      threeGLTF,\n      threeObjectMap\n    } = correlatedSceneGraph;\n    this[$modelVariants] = modelVariants;\n    this.mesh.userData.variantData = modelVariants; // Captures the primitive's initial material.\n\n    const materialMappings = threeObjectMap.get(mesh.material);\n\n    if (materialMappings.materials != null) {\n      this[$initialMaterialIdx] = this[$activeMaterialIdx] = materialMappings.materials;\n    } else {\n      console.error(`Primitive (${mesh.name}) missing initial material reference.`);\n    } // Gets the mesh index from the node.\n\n\n    const associations = mesh.userData.associations || {};\n\n    if (associations.meshes == null) {\n      console.error('Mesh is missing primitive index association');\n      return;\n    } // The gltf mesh array to sample from.\n\n\n    const meshElementArray = gltf['meshes'] || []; // List of primitives under the mesh.\n\n    const gltfPrimitives = meshElementArray[associations.meshes].primitives || [];\n    const gltfPrimitive = gltfPrimitives[associations.primitives];\n\n    if (gltfPrimitive == null) {\n      console.error('Mesh primitive definition is missing.');\n      return;\n    } // Maps the gltfPrimitive default to a material.\n\n\n    if (gltfPrimitive.material != null) {\n      this[$materials].set(gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);\n    } else {\n      const defaultIdx = mvMaterials.findIndex(mat => {\n        return mat.name === 'Default';\n      });\n\n      if (defaultIdx >= 0) {\n        this[$materials].set(defaultIdx, mvMaterials[defaultIdx]);\n      } else {\n        console.warn('gltfPrimitive has no material!');\n      }\n    }\n\n    if (gltfPrimitive.extensions && gltfPrimitive.extensions['KHR_materials_variants']) {\n      const variantsExtension = gltfPrimitive.extensions['KHR_materials_variants'];\n      const extensions = threeGLTF.parser.json.extensions;\n      const variantNames = extensions['KHR_materials_variants'].variants; // Provides definition now that we know there are variants to\n      // support.\n\n      for (const mapping of variantsExtension.mappings) {\n        const mvMaterial = mvMaterials[mapping.material]; // Maps variant indices to Materials.\n\n        this[$materials].set(mapping.material, mvMaterial);\n\n        for (const variant of mapping.variants) {\n          const {\n            name\n          } = variantNames[variant];\n          this[$variantToMaterialMap].set(variant, mvMaterial); // Provides variant info for material self lookup.\n\n          mvMaterial[$variantIndices]().add(variant); // Updates the models variant data.\n\n          if (!modelVariants.has(name)) {\n            modelVariants.set(name, {\n              name,\n              index: variant\n            });\n          }\n        }\n      }\n    }\n  }\n\n  get mesh() {\n    return this[$mesh];\n  }\n\n  async setActiveMaterial(material) {\n    const mvMaterial = this[$materials].get(material);\n\n    if (mvMaterial != null) {\n      this.mesh.material = await mvMaterial[$getLoadedMaterial]();\n      this[$activeMaterialIdx] = material;\n    }\n\n    return this.mesh.material;\n  }\n\n  getActiveMaterial() {\n    return this[$materials].get(this[$activeMaterialIdx]);\n  }\n\n  getMaterial(index) {\n    return this[$materials].get(index);\n  }\n\n  async enableVariant(name) {\n    if (name == null) {\n      return this.setActiveMaterial(this[$initialMaterialIdx]);\n    }\n\n    if (this[$variantToMaterialMap] != null && this[$modelVariants].has(name)) {\n      const modelVariants = this[$modelVariants].get(name);\n      return this.enableVariantHelper(modelVariants.index);\n    }\n\n    return null;\n  }\n\n  async enableVariantHelper(index) {\n    if (this[$variantToMaterialMap] != null && index != null) {\n      const material = this[$variantToMaterialMap].get(index);\n\n      if (material != null) {\n        return this.setActiveMaterial(material.index);\n      }\n    }\n\n    return null;\n  }\n\n  async instantiateVariants() {\n    if (this[$variantToMaterialMap] == null) {\n      return;\n    }\n\n    for (const index of this[$variantToMaterialMap].keys()) {\n      const variantMaterial = this.mesh.userData.variantMaterials.get(index);\n\n      if (variantMaterial.material != null) {\n        continue;\n      }\n\n      const threeMaterial = await this.enableVariantHelper(index);\n\n      if (threeMaterial != null) {\n        variantMaterial.material = threeMaterial;\n      }\n    }\n  }\n\n  get variantInfo() {\n    return this[$variantToMaterialMap];\n  }\n\n  addVariant(materialVariant, variantName) {\n    if (!this.ensureVariantIsUnused(variantName)) {\n      return false;\n    } // Adds the variant to the model variants if needed.\n\n\n    if (!this[$modelVariants].has(variantName)) {\n      this[$modelVariants].set(variantName, {\n        name: variantName,\n        index: this[$modelVariants].size\n      });\n    }\n\n    const modelVariantData = this[$modelVariants].get(variantName);\n    const variantIndex = modelVariantData.index; // Updates materials mapped to the variant.\n\n    materialVariant[$variantIndices]().add(variantIndex); // Updates internal mappings.\n\n    this[$variantToMaterialMap].set(variantIndex, materialVariant);\n    this[$materials].set(materialVariant.index, materialVariant);\n    this.updateVariantUserData(variantIndex, materialVariant);\n    return true;\n  }\n\n  deleteVariant(variantIndex) {\n    if (this.variantInfo.has(variantIndex)) {\n      this.variantInfo.delete(variantIndex);\n      const userDataMap = this.mesh.userData.variantMaterials;\n\n      if (userDataMap != null) {\n        userDataMap.delete(variantIndex);\n      }\n    }\n  }\n\n  updateVariantUserData(variantIndex, materialVariant) {\n    // Adds variants name to material variants set.\n    materialVariant[$variantIndices]().add(variantIndex);\n    this.mesh.userData.variantData = this[$modelVariants]; // Updates import data (see VariantMaterialLoaderPlugin.ts).\n\n    this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map();\n    const map = this.mesh.userData.variantMaterials;\n    map.set(variantIndex, {\n      material: materialVariant[$correlatedObjects].values().next().value,\n      gltfMaterialIndex: materialVariant.index\n    });\n  }\n\n  ensureVariantIsUnused(variantName) {\n    const modelVariants = this[$modelVariants].get(variantName);\n\n    if (modelVariants != null && this.variantInfo.has(modelVariants.index)) {\n      console.warn(`Primitive cannot add variant '${variantName}' for this material, it already exists.`);\n      return false;\n    }\n\n    return true;\n  }\n\n}\n_b = $materials, _c = $variantToMaterialMap, _d = $initialMaterialIdx, _e = $activeMaterialIdx; //# sourceMappingURL=primitive-node.js.map","map":null,"metadata":{},"sourceType":"module"}