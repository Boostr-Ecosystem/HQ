{"ast":null,"code":"import { markToTrack, getUntracked } from 'proxy-compare';\n\nconst isObject = x => typeof x === \"object\" && x !== null;\n\nconst proxyStateMap = /* @__PURE__ */new WeakMap();\nconst refSet = /* @__PURE__ */new WeakSet();\n\nconst buildProxyFunction = function () {\n  let objectIs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.is;\n  let newProxy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (target, handler) => new Proxy(target, handler);\n  let canProxy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n  let defaultHandlePromise = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : promise => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value;\n\n      case \"rejected\":\n        throw promise.reason;\n\n      default:\n        throw promise;\n    }\n  };\n  let snapCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : /* @__PURE__ */new WeakMap();\n  let createSnapshot = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (target, version) {\n    let handlePromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultHandlePromise;\n    const cache = snapCache.get(target);\n\n    if ((cache == null ? void 0 : cache[0]) === version) {\n      return cache[1];\n    }\n\n    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n    markToTrack(snap, true);\n    snapCache.set(target, [version, snap]);\n    Reflect.ownKeys(target).forEach(key => {\n      if (Object.getOwnPropertyDescriptor(snap, key)) {\n        return;\n      }\n\n      const value = Reflect.get(target, key);\n      const desc = {\n        value,\n        enumerable: true,\n        // This is intentional to avoid copying with proxy-compare.\n        // It's still non-writable, so it avoids assigning a value.\n        configurable: true\n      };\n\n      if (refSet.has(value)) {\n        markToTrack(value, false);\n      } else if (value instanceof Promise) {\n        delete desc.value;\n\n        desc.get = () => handlePromise(value);\n      } else if (proxyStateMap.has(value)) {\n        const [target2, ensureVersion] = proxyStateMap.get(value);\n        desc.value = createSnapshot(target2, ensureVersion(), handlePromise);\n      }\n\n      Object.defineProperty(snap, key, desc);\n    });\n    return snap;\n  };\n  let proxyCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : /* @__PURE__ */new WeakMap();\n  let versionHolder = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [1, 1];\n  let proxyFunction = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : initialObject => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\");\n    }\n\n    const found = proxyCache.get(initialObject);\n\n    if (found) {\n      return found;\n    }\n\n    let version = versionHolder[0];\n    const listeners = /* @__PURE__ */new Set();\n\n    const notifyUpdate = function (op) {\n      let nextVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ++versionHolder[0];\n\n      if (version !== nextVersion) {\n        version = nextVersion;\n        listeners.forEach(listener => listener(op, nextVersion));\n      }\n    };\n\n    let checkVersion = versionHolder[1];\n\n    const ensureVersion = function () {\n      let nextCheckVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ++versionHolder[1];\n\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion;\n        propProxyStates.forEach(_ref => {\n          let [propProxyState] = _ref;\n          const propVersion = propProxyState[1](nextCheckVersion);\n\n          if (propVersion > version) {\n            version = propVersion;\n          }\n        });\n      }\n\n      return version;\n    };\n\n    const createPropListener = prop => (op, nextVersion) => {\n      const newOp = [...op];\n      newOp[1] = [prop, ...newOp[1]];\n      notifyUpdate(newOp, nextVersion);\n    };\n\n    const propProxyStates = /* @__PURE__ */new Map();\n\n    const addPropListener = (prop, propProxyState) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    };\n\n    const removePropListener = prop => {\n      var _a;\n\n      const entry = propProxyStates.get(prop);\n\n      if (entry) {\n        propProxyStates.delete(prop);\n        (_a = entry[1]) == null ? void 0 : _a.call(entry);\n      }\n    };\n\n    const addListener = listener => {\n      listeners.add(listener);\n\n      if (listeners.size === 1) {\n        propProxyStates.forEach((_ref2, prop) => {\n          let [propProxyState, prevRemove] = _ref2;\n\n          if ((import.meta.env && import.meta.env.MODE) !== \"production\" && prevRemove) {\n            throw new Error(\"remove already exists\");\n          }\n\n          const remove = propProxyState[3](createPropListener(prop));\n          propProxyStates.set(prop, [propProxyState, remove]);\n        });\n      }\n\n      const removeListener = () => {\n        listeners.delete(listener);\n\n        if (listeners.size === 0) {\n          propProxyStates.forEach((_ref3, prop) => {\n            let [propProxyState, remove] = _ref3;\n\n            if (remove) {\n              remove();\n              propProxyStates.set(prop, [propProxyState]);\n            }\n          });\n        }\n      };\n\n      return removeListener;\n    };\n\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n    const handler = {\n      deleteProperty(target, prop) {\n        const prevValue = Reflect.get(target, prop);\n        removePropListener(prop);\n        const deleted = Reflect.deleteProperty(target, prop);\n\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue]);\n        }\n\n        return deleted;\n      },\n\n      set(target, prop, value, receiver) {\n        const hasPrevValue = Reflect.has(target, prop);\n        const prevValue = Reflect.get(target, prop, receiver);\n\n        if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n          return true;\n        }\n\n        removePropListener(prop);\n\n        if (isObject(value)) {\n          value = getUntracked(value) || value;\n        }\n\n        let nextValue = value;\n\n        if (value instanceof Promise) {\n          value.then(v => {\n            value.status = \"fulfilled\";\n            value.value = v;\n            notifyUpdate([\"resolve\", [prop], v]);\n          }).catch(e => {\n            value.status = \"rejected\";\n            value.reason = e;\n            notifyUpdate([\"reject\", [prop], e]);\n          });\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxyFunction(value);\n          }\n\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n\n          if (childProxyState) {\n            addPropListener(prop, childProxyState);\n          }\n        }\n\n        Reflect.set(target, prop, nextValue, receiver);\n        notifyUpdate([\"set\", [prop], value, prevValue]);\n        return true;\n      }\n\n    };\n    const proxyObject = newProxy(baseObject, handler);\n    proxyCache.set(initialObject, proxyObject);\n    const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n    proxyStateMap.set(proxyObject, proxyState);\n    Reflect.ownKeys(initialObject).forEach(key => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n\n      if (\"value\" in desc) {\n        proxyObject[key] = initialObject[key];\n        delete desc.value;\n        delete desc.writable;\n      }\n\n      Object.defineProperty(baseObject, key, desc);\n    });\n    return proxyObject;\n  };\n  return [// public functions\n  proxyFunction, // shared state\n  proxyStateMap, refSet, // internal things\n  objectIs, newProxy, canProxy, defaultHandlePromise, snapCache, createSnapshot, proxyCache, versionHolder];\n};\n\nconst [defaultProxyFunction] = buildProxyFunction();\n\nfunction proxy() {\n  let initialObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return defaultProxyFunction(initialObject);\n}\n\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\n\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n\n  const listener = op => {\n    ops.push(op);\n\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\n\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\n\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\nconst unstable_buildProxyFunction = buildProxyFunction;\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction };","map":null,"metadata":{},"sourceType":"module"}