{"ast":null,"code":"import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-eea39a9a.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { b as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../../dist/errors-e1a2656b.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js';\nimport { InjectedConnector } from '../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js';\nimport { utils } from 'ethers';\nimport '../../../../dist/checkPrivateRedeclaration-3aaaa21d.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nimport '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\n\nclass MetaMaskConnector extends InjectedConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      name: \"MetaMask\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n\n      getProvider() {\n        function getReady(ethereum) {\n          const isMetaMask = !!ethereum?.isMetaMask;\n\n          if (!isMetaMask) {\n            return;\n          } // Brave tries to make itself look like MetaMask\n          // Could also try RPC `web3_clientVersion` if following is unreliable\n\n\n          if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) {\n            return;\n          }\n\n          if (ethereum.isAvalanche) {\n            return;\n          }\n\n          if (ethereum.isKuCoinWallet) {\n            return;\n          }\n\n          if (ethereum.isPortal) {\n            return;\n          }\n\n          if (ethereum.isTokenPocket) {\n            return;\n          }\n\n          if (ethereum.isTokenary) {\n            return;\n          }\n\n          return ethereum;\n        }\n\n        if (assertWindowEthereum(globalThis.window)) {\n          if (globalThis.window.ethereum?.providers) {\n            return globalThis.window.ethereum.providers.find(getReady);\n          }\n\n          return getReady(globalThis.window.ethereum);\n        }\n      }\n\n    };\n    const options = { ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options,\n      connectorStorage: arg.connectorStorage\n    });\n\n    _defineProperty(this, \"id\", \"metaMask\");\n\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n  /**\n   * Connect to injected MetaMask provider\n   */\n\n\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      const provider = await this.getProvider();\n\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n\n      this.setupListeners(); // emit \"connecting\" event\n\n      this.emit(\"message\", {\n        type: \"connecting\"\n      }); // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n\n      let account = null;\n\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n\n        if (isConnected) {\n          // Attempt to show another prompt for selecting wallet if already connected\n          try {\n            await provider.request({\n              method: \"wallet_requestPermissions\",\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n          } catch (error) {\n            // Not all MetaMask injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (this.isUserRejectedRequestError(error)) {\n              throw new UserRejectedRequestError(error);\n            }\n          }\n        }\n      } // if account is not already set, request accounts and use the first account\n\n\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = utils.getAddress(accounts[0]);\n      } // get currently connected chainId\n\n\n      let connectedChainId = await this.getChainId(); // check if connected chain is unsupported\n\n      let isUnsupported = this.isChainUnsupported(connectedChainId); // if chainId is given, but does not match the currently connected chainId, switch to the given chainId\n\n      if (options.chainId && connectedChainId !== options.chainId) {\n        try {\n          await this.switchChain(options.chainId); // recalculate the chainId and isUnsupported\n\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id : ${options.chainId}`, e);\n        }\n      } // if shimDisconnect is enabled\n\n\n      if (this.options?.shimDisconnect) {\n        // add shimDisconnectKey in storage - this signals that connector is \"connected\"\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n\n      const connectionInfo = {\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider: provider,\n        account\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n\n      throw error;\n    }\n  }\n\n}\n\nexport { MetaMaskConnector };","map":null,"metadata":{},"sourceType":"module"}