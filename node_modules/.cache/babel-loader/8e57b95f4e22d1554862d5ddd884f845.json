{"ast":null,"code":"import { EventEmitter as R } from \"events\";\nimport { getAccountsFromNamespaces as S, getSdkError as T, isValidArray as v } from \"@walletconnect/utils\";\nimport { UniversalProvider as P } from \"@walletconnect/universal-provider\";\nconst j = \"wc\",\n      $ = \"ethereum_provider\",\n      N = `${j}@${2}:${$}:`,\n      D = \"https://rpc.walletconnect.com/v1/\",\n      p = [\"eth_sendTransaction\", \"personal_sign\"],\n      q = [\"eth_accounts\", \"eth_requestAccounts\", \"eth_call\", \"eth_getBalance\", \"eth_sendRawTransaction\", \"eth_sign\", \"eth_signTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"wallet_switchEthereumChain\", \"wallet_addEthereumChain\", \"wallet_getPermissions\", \"wallet_requestPermissions\", \"wallet_registerOnboarding\", \"wallet_watchAsset\", \"wallet_scanQRCode\"],\n      u = [\"chainChanged\", \"accountsChanged\"],\n      U = [\"message\", \"disconnect\", \"connect\"];\n\nvar L = Object.defineProperty,\n    Q = Object.defineProperties,\n    H = Object.getOwnPropertyDescriptors,\n    E = Object.getOwnPropertySymbols,\n    G = Object.prototype.hasOwnProperty,\n    K = Object.prototype.propertyIsEnumerable,\n    _ = (a, t, s) => t in a ? L(a, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: s\n}) : a[t] = s,\n    y = (a, t) => {\n  for (var s in t || (t = {})) G.call(t, s) && _(a, s, t[s]);\n\n  if (E) for (var s of E(t)) K.call(t, s) && _(a, s, t[s]);\n  return a;\n},\n    O = (a, t) => Q(a, H(t));\n\nfunction I(a) {\n  return Number(a[0].split(\":\")[1]);\n}\n\nfunction C(a) {\n  return `0x${a.toString(16)}`;\n}\n\nfunction V(a) {\n  const {\n    chains: t,\n    optionalChains: s,\n    methods: i,\n    optionalMethods: e,\n    events: n,\n    optionalEvents: c,\n    rpcMap: h\n  } = a;\n  if (!v(t)) throw new Error(\"Invalid chains\");\n  const o = t,\n        r = i || p,\n        w = n || u,\n        b = {\n    [I(o)]: h[I(o)]\n  },\n        f = {\n    chains: o,\n    methods: r,\n    events: w,\n    rpcMap: b\n  },\n        d = n?.filter(g => !u.includes(g)),\n        l = i?.filter(g => !p.includes(g));\n  if (!s && !c && !e && !(d != null && d.length) && !(l != null && l.length)) return {\n    required: f\n  };\n  const A = d?.length && l?.length || !s,\n        M = {\n    chains: [...new Set(A ? o.concat(s || []) : s)],\n    methods: [...new Set(r.concat(e || []))],\n    events: [...new Set(w.concat(c || []))],\n    rpcMap: h\n  };\n  return {\n    required: f,\n    optional: M\n  };\n}\n\nclass m {\n  constructor() {\n    this.events = new R(), this.namespace = \"eip155\", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = N, this.on = (t, s) => (this.events.on(t, s), this), this.once = (t, s) => (this.events.once(t, s), this), this.removeListener = (t, s) => (this.events.removeListener(t, s), this), this.off = (t, s) => (this.events.off(t, s), this), this.parseAccount = t => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {};\n  }\n\n  static async init(t) {\n    const s = new m();\n    return await s.initialize(t), s;\n  }\n\n  async request(t) {\n    return await this.signer.request(t, this.formatChainId(this.chainId));\n  }\n\n  sendAsync(t, s) {\n    this.signer.sendAsync(t, s, this.formatChainId(this.chainId));\n  }\n\n  get connected() {\n    return this.signer.client ? this.signer.client.core.relayer.connected : !1;\n  }\n\n  get connecting() {\n    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;\n  }\n\n  async enable() {\n    return this.session || (await this.connect()), await this.request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n\n  async connect(t) {\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts(t);\n    const {\n      required: s,\n      optional: i\n    } = V(this.rpc);\n\n    try {\n      const e = await new Promise(async (c, h) => {\n        var o;\n        this.rpc.showQrModal && ((o = this.modal) == null || o.subscribeModal(r => {\n          !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), h(new Error(\"Connection request reset. Please try again.\")));\n        })), await this.signer.connect(O(y({\n          namespaces: {\n            [this.namespace]: s\n          }\n        }, i && {\n          optionalNamespaces: {\n            [this.namespace]: i\n          }\n        }), {\n          pairingTopic: t?.pairingTopic\n        })).then(r => {\n          c(r);\n        }).catch(r => {\n          h(new Error(r.message));\n        });\n      });\n      if (!e) return;\n      this.setChainIds(this.rpc.chains);\n      const n = S(e.namespaces, [this.namespace]);\n      this.setAccounts(n), this.events.emit(\"connect\", {\n        chainId: C(this.chainId)\n      });\n    } catch (e) {\n      throw this.signer.logger.error(e), e;\n    } finally {\n      this.modal && this.modal.closeModal();\n    }\n  }\n\n  async disconnect() {\n    this.session && (await this.signer.disconnect()), this.reset();\n  }\n\n  get isWalletConnect() {\n    return !0;\n  }\n\n  get session() {\n    return this.signer.session;\n  }\n\n  registerEventListeners() {\n    this.signer.on(\"session_event\", t => {\n      const {\n        params: s\n      } = t,\n            {\n        event: i\n      } = s;\n      i.name === \"accountsChanged\" ? (this.accounts = this.parseAccounts(i.data), this.events.emit(\"accountsChanged\", this.accounts)) : i.name === \"chainChanged\" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit(\"session_event\", t);\n    }), this.signer.on(\"chainChanged\", t => {\n      const s = parseInt(t);\n      this.chainId = s, this.events.emit(\"chainChanged\", C(this.chainId)), this.persist();\n    }), this.signer.on(\"session_update\", t => {\n      this.events.emit(\"session_update\", t);\n    }), this.signer.on(\"session_delete\", t => {\n      this.reset(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", O(y({}, T(\"USER_DISCONNECTED\")), {\n        data: t.topic,\n        name: \"USER_DISCONNECTED\"\n      }));\n    }), this.signer.on(\"display_uri\", t => {\n      var s, i;\n      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({\n        uri: t\n      })), this.events.emit(\"display_uri\", t);\n    });\n  }\n\n  setHttpProvider(t) {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: t.toString(16)\n      }]\n    });\n  }\n\n  isCompatibleChainId(t) {\n    return typeof t == \"string\" ? t.startsWith(`${this.namespace}:`) : !1;\n  }\n\n  formatChainId(t) {\n    return `${this.namespace}:${t}`;\n  }\n\n  parseChainId(t) {\n    return Number(t.split(\":\")[1]);\n  }\n\n  setChainIds(t) {\n    const s = t.filter(i => this.isCompatibleChainId(i)).map(i => this.parseChainId(i));\n    s.length && (this.chainId = s[0], this.events.emit(\"chainChanged\", C(this.chainId)), this.persist());\n  }\n\n  setChainId(t) {\n    if (this.isCompatibleChainId(t)) {\n      const s = this.parseChainId(t);\n      this.chainId = s, this.setHttpProvider(s);\n    }\n  }\n\n  parseAccountId(t) {\n    const [s, i, e] = t.split(\":\");\n    return {\n      chainId: `${s}:${i}`,\n      address: e\n    };\n  }\n\n  setAccounts(t) {\n    this.accounts = t.filter(s => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map(s => this.parseAccountId(s).address), this.events.emit(\"accountsChanged\", this.accounts);\n  }\n\n  getRpcConfig(t) {\n    var s, i;\n    return {\n      chains: ((s = t.chains) == null ? void 0 : s.map(e => this.formatChainId(e))) || [`${this.namespace}:1`],\n      optionalChains: t.optionalChains ? t.optionalChains.map(e => this.formatChainId(e)) : void 0,\n      methods: t?.methods || p,\n      events: t?.events || u,\n      optionalMethods: t?.optionalMethods || [],\n      optionalEvents: t?.optionalEvents || [],\n      rpcMap: t?.rpcMap || this.buildRpcMap(t.chains.concat(t.optionalChains || []), t.projectId),\n      showQrModal: (i = t?.showQrModal) != null ? i : !0,\n      projectId: t.projectId,\n      metadata: t.metadata\n    };\n  }\n\n  buildRpcMap(t, s) {\n    const i = {};\n    return t.forEach(e => {\n      i[e] = this.getRpcUrl(e, s);\n    }), i;\n  }\n\n  async initialize(t) {\n    if (this.rpc = this.getRpcConfig(t), this.chainId = I(this.rpc.chains), this.signer = await P.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata\n    }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {\n      const {\n        Web3Modal: s\n      } = await import(\"@web3modal/standalone\");\n      this.modal = new s({\n        walletConnectVersion: 2,\n        projectId: this.rpc.projectId,\n        standaloneChains: this.rpc.chains\n      });\n    }\n  }\n\n  loadConnectOpts(t) {\n    if (!t) return;\n    const {\n      chains: s,\n      optionalChains: i,\n      rpcMap: e\n    } = t;\n    s && v(s) && (this.rpc.chains = s.map(n => this.formatChainId(n)), s.forEach(n => {\n      this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);\n    })), i && v(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i?.map(n => this.formatChainId(n)), i.forEach(n => {\n      this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);\n    }));\n  }\n\n  getRpcUrl(t, s) {\n    var i;\n    return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${D}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;\n  }\n\n  async loadPersistedSession() {\n    if (!this.session) return;\n    const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);\n    this.setChainIds(t ? [this.formatChainId(t)] : this.session.namespaces[this.namespace].accounts), this.setAccounts(this.session.namespaces[this.namespace].accounts);\n  }\n\n  reset() {\n    this.chainId = 1, this.accounts = [];\n  }\n\n  persist() {\n    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n\n  parseAccounts(t) {\n    return typeof t == \"string\" || t instanceof String ? [this.parseAccount(t)] : t.map(s => this.parseAccount(s));\n  }\n\n}\n\nconst Y = m;\nexport { Y as EthereumProvider, U as OPTIONAL_EVENTS, q as OPTIONAL_METHODS, u as REQUIRED_EVENTS, p as REQUIRED_METHODS, m as default }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}