{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SafeEthersSigner = void 0;\n\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\n\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\n\nconst safe_core_sdk_types_1 = require(\"@safe-global/safe-core-sdk-types\");\n\nconst utils_1 = require(\"./utils\");\n\nconst sleep = duration => new Promise(resolve => setTimeout(resolve, duration));\n\nclass SafeEthersSigner extends abstract_signer_1.VoidSigner {\n  /**\n   * Creates an instance of the SafeEthersSigner.\n   * @param safe - Safe that should be used\n   * @param service - Services to which the transactions should be proposed to\n   * @param provider - (Optional) Provider that should be used for blockchain interactions. By default the provider from the signer is used.\n   * @param options - (Optional) Additional options (e.g. polling delay when waiting for a transaction to be mined)\n   * @returns The SafeEthersSigner instance\n   */\n  constructor(safe, service, provider, options) {\n    super(safe.getAddress(), provider);\n    this.service = service;\n    this.safe = safe;\n    this.options = options;\n  }\n\n  async buildTransactionResponse(safeTxHash, safeTx) {\n    const connectedSafe = await this.safe;\n    const connectedService = this.service;\n    return {\n      to: safeTx.to,\n      value: bignumber_1.BigNumber.from(safeTx.value),\n      data: safeTx.data,\n      operation: safeTx.operation,\n      gasLimit: bignumber_1.BigNumber.from(safeTx.safeTxGas),\n      gasPrice: bignumber_1.BigNumber.from(0),\n      nonce: safeTx.nonce,\n      chainId: await connectedSafe.getChainId(),\n      hash: safeTxHash,\n      from: this.address,\n      confirmations: 0,\n      wait: async confirmations => {\n        var _a, _b;\n\n        while (true) {\n          try {\n            const txDetails = await connectedService.getSafeTxDetails(safeTxHash);\n\n            if (txDetails.transactionHash) {\n              this._checkProvider('sendTransaction');\n\n              const receipt = await this.provider.waitForTransaction(txDetails.transactionHash, confirmations);\n              return (0, utils_1.mapReceipt)(receipt, safeTx);\n            }\n          } catch (e) {}\n\n          await sleep((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.pollingDelay) !== null && _b !== void 0 ? _b : 5000);\n        }\n      }\n    };\n  }\n  /**\n   * Populates all fields in a transaction, signs it and sends it to the Safe transaction service\n   *\n   * @param transaction - The transaction what should be send\n   * @returns A promise that resolves to a SafeTransactionReponse, that contains all the information of the transaction.\n   */\n\n\n  async sendTransaction(transaction) {\n    var _a, _b, _c;\n\n    const tx = await transaction;\n    let operation = safe_core_sdk_types_1.OperationType.Call;\n    let to = await tx.to;\n    let data = (_b = (_a = await tx.data) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '0x';\n    let value = bignumber_1.BigNumber.from((_c = await tx.value) !== null && _c !== void 0 ? _c : 0);\n\n    if (!to) {\n      to = utils_1.createLibAddress;\n      data = utils_1.createLibInterface.encodeFunctionData('performCreate', [value, data]);\n      value = bignumber_1.BigNumber.from(0);\n      operation = safe_core_sdk_types_1.OperationType.DelegateCall;\n    }\n\n    const baseTx = {\n      to: to,\n      data,\n      value: value.toString(),\n      operation\n    };\n    const safeTxGas = await this.service.estimateSafeTx(this.address, baseTx);\n    const connectedSafe = await this.safe;\n    const safeTransactionData = { ...baseTx,\n      safeTxGas: safeTxGas.toNumber()\n    };\n    const safeTx = await connectedSafe.createTransaction({\n      safeTransactionData\n    });\n    const safeTxHash = await connectedSafe.getTransactionHash(safeTx);\n    const signature = await connectedSafe.signTransactionHash(safeTxHash);\n    await this.service.proposeTx(this.address, safeTxHash, safeTx, signature); // TODO: maybe use original tx information\n\n    return this.buildTransactionResponse(safeTxHash, safeTx.data);\n  }\n\n}\n\nexports.SafeEthersSigner = SafeEthersSigner; //# sourceMappingURL=signer.js.map","map":null,"metadata":{},"sourceType":"script"}