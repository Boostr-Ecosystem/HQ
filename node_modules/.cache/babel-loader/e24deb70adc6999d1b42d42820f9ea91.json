{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-9d546189.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-eea39a9a.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { C as Connector, U as UserRejectedRequestError, S as SwitchChainError } from '../../../../dist/errors-e1a2656b.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport '../../../../dist/checkPrivateRedeclaration-3aaaa21d.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n/**\n * Wallets that support chain switching through WalletConnect\n * - imToken (token.im)\n * - MetaMask (metamask.io)\n * - Rainbow (rainbow.me)\n * - Trust Wallet (trustwallet.com)\n */\n// const switchChainAllowedRegex = /(imtoken|metamask|rainbow|trust wallet)/i;\n\nconst LAST_USED_CHAIN_ID = \"last-used-chain-id\";\nconst LAST_SESSION = \"last-session\";\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _storage = /*#__PURE__*/new WeakMap();\n\nvar _handleConnected = /*#__PURE__*/new WeakSet();\n\nvar _removeListeners = /*#__PURE__*/new WeakSet();\n\nclass WalletConnectV1Connector extends Connector {\n  constructor(config) {\n    super(config);\n\n    _classPrivateMethodInitSpec(this, _removeListeners);\n\n    _classPrivateMethodInitSpec(this, _handleConnected);\n\n    _defineProperty(this, \"id\", \"walletConnectV1\");\n\n    _defineProperty(this, \"name\", \"WalletConnectV1\");\n\n    _defineProperty(this, \"ready\", true);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _storage, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"walletName\", void 0);\n\n    _defineProperty(this, \"onSwitchChain\", () => {\n      this.emit(\"message\", {\n        type: \"switch_chain\"\n      });\n    });\n\n    _defineProperty(this, \"onDisplayUri\", async (error, payload) => {\n      if (error) {\n        this.emit(\"message\", {\n          data: error,\n          type: \"display_uri_error\"\n        });\n      }\n\n      this.emit(\"message\", {\n        data: payload.params[0],\n        type: \"display_uri\"\n      });\n    });\n\n    _defineProperty(this, \"onRequestSent\", (error, payload) => {\n      if (error) {\n        this.emit(\"message\", {\n          data: error,\n          type: \"request\"\n        });\n      }\n\n      this.emit(\"message\", {\n        data: payload.params[0],\n        type: \"request\"\n      });\n    });\n\n    _defineProperty(this, \"onMessage\", message => {\n      this.emit(\"message\", message);\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n\n      _classPrivateFieldGet(this, _storage).setItem(LAST_USED_CHAIN_ID, String(chainId));\n\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", async () => {\n      this.walletName = undefined;\n\n      _classPrivateFieldGet(this, _storage).removeItem(LAST_USED_CHAIN_ID);\n\n      _classPrivateFieldGet(this, _storage).removeItem(LAST_SESSION);\n\n      _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);\n\n      this.emit(\"disconnect\");\n    });\n\n    _classPrivateFieldSet(this, _storage, config.storage);\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      let targetChainId = chainId;\n\n      if (!targetChainId) {\n        const lastUsedChainIdStr = await _classPrivateFieldGet(this, _storage).getItem(LAST_USED_CHAIN_ID);\n        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;\n\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {\n          targetChainId = lastUsedChainId;\n        }\n      }\n\n      const provider = await this.getProvider({\n        chainId: targetChainId,\n        create: true\n      });\n      this.setupListeners(); // Defer message to the next tick to ensure wallet connect data (provided by `.enable()`) is available\n\n      setTimeout(() => this.emit(\"message\", {\n        type: \"connecting\"\n      }), 0);\n      const accounts = await provider.enable();\n      const account = utils.getAddress(accounts[0]);\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id); // Not all WalletConnect options support programmatic chain switching\n      // Only enable for wallet options that do\n\n      this.walletName = provider.connector?.peerMeta?.name ?? \"\"; // switch to target chainId\n\n      if (chainId) {\n        try {\n          await this.switchChain(chainId);\n          id = chainId;\n          unsupported = this.isChainUnsupported(id);\n        } catch (e) {\n          console.error(`could not switch to desired chain id: ${chainId} `, e);\n        }\n      }\n\n      _classPrivateMethodGet(this, _handleConnected, _handleConnected2).call(this);\n\n      this.emit(\"connect\", {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      });\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user closed modal/i.test(error.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    const provider = await this.getProvider();\n    await provider.disconnect();\n  }\n\n  async getAccount() {\n    const provider = await this.getProvider();\n    const accounts = provider.accounts; // return checksum address\n\n    return utils.getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const provider = await this.getProvider();\n    const chainId = normalizeChainId(provider.chainId);\n    return chainId;\n  }\n\n  async getProvider() {\n    let {\n      chainId,\n      create\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Force create new provider\n\n    if (!_classPrivateFieldGet(this, _provider) || chainId || create) {\n      const rpc = !this.options?.infuraId ? this.chains.reduce((rpc_, chain) => ({ ...rpc_,\n        [chain.chainId]: chain.rpc[0]\n      }), {}) : {};\n      const WalletConnectProvider = (await import('../../../../dist/index-42b0f5f5.browser.esm.js')).default;\n      const sessionStr = await _classPrivateFieldGet(this, _storage).getItem(LAST_SESSION);\n      const session = sessionStr ? JSON.parse(sessionStr) : undefined;\n      this.walletName = session?.peerMeta?.name || undefined;\n\n      _classPrivateFieldSet(this, _provider, new WalletConnectProvider({ ...this.options,\n        chainId,\n        rpc: { ...rpc,\n          ...this.options?.rpc\n        },\n        session: session ? session : undefined\n      }));\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const chainIdHex = utils.hexValue(chainId);\n\n    try {\n      // Set up a race between `wallet_switchEthereumChain` & the `chainChanged` event\n      // to ensure the chain has been switched. This is because there could be a case\n      // where a wallet may not resolve the `wallet_switchEthereumChain` method, or\n      // resolves slower than `chainChanged`.\n      await Promise.race([provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainIdHex\n        }]\n      }), new Promise(res => this.on(\"change\", _ref => {\n        let {\n          chain\n        } = _ref;\n\n        if (chain?.id === chainId) {\n          res(chainId);\n        }\n      }))]);\n      return this.chains.find(x => x.chainId === chainId) ?? {\n        chainId: chainId,\n        name: `Chain ${chainIdHex}`,\n        network: `${chainIdHex}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpc: [\"\"],\n        shortName: \"eth\",\n        chain: \"ETH\",\n        slug: \"ethereum\",\n        testnet: false\n      };\n    } catch (error) {\n      const message = typeof error === \"string\" ? error : error?.message;\n\n      if (/user rejected request/i.test(message)) {\n        throw new UserRejectedRequestError(error);\n      }\n\n      const chain = this.chains.find(x => x.chainId === chainId); // if chain is not supported\n\n      if (!chain) {\n        throw new SwitchChainError(`Chain ${chainId} is not added in the list of supported chains`);\n      }\n\n      console.log({\n        chain\n      }); // if chain is not configured in the wallet\n\n      if (/Unrecognized chain ID/i.test(message)) {\n        // configure it\n        this.emit(\"message\", {\n          type: \"add_chain\"\n        });\n        const blockExplorerUrls = this.getBlockExplorerUrls(chain);\n        await provider.request({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId: chainIdHex,\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: chain.rpc,\n            blockExplorerUrls\n          }]\n        });\n        return chain;\n      } else {\n        throw new SwitchChainError(error);\n      }\n    }\n  }\n\n  async setupListeners() {\n    if (!_classPrivateFieldGet(this, _provider)) {\n      return;\n    }\n\n    _classPrivateFieldGet(this, _provider).on(\"accountsChanged\", this.onAccountsChanged);\n\n    _classPrivateFieldGet(this, _provider).on(\"chainChanged\", this.onChainChanged);\n\n    _classPrivateFieldGet(this, _provider).on(\"disconnect\", this.onDisconnect);\n\n    _classPrivateFieldGet(this, _provider).on(\"message\", this.onMessage);\n\n    _classPrivateFieldGet(this, _provider).on(\"switchChain\", this.onSwitchChain);\n\n    _classPrivateFieldGet(this, _provider).on(\"display_uri\", this.onDisplayUri);\n\n    _classPrivateFieldGet(this, _provider).on(\"call_request_sent\", this.onRequestSent);\n  }\n\n}\n\nasync function _handleConnected2() {\n  const session = _classPrivateFieldGet(this, _provider)?.connector.session;\n  this.walletName = session?.peerMeta?.name || \"\";\n  const sessionStr = JSON.stringify(session);\n\n  _classPrivateFieldGet(this, _storage).setItem(LAST_SESSION, sessionStr);\n}\n\nfunction _removeListeners2() {\n  if (!_classPrivateFieldGet(this, _provider)) {\n    return;\n  }\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"accountsChanged\", this.onAccountsChanged);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"chainChanged\", this.onChainChanged);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"disconnect\", this.onDisconnect);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"message\", this.onMessage);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"switchChain\", this.onSwitchChain);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"display_uri\", this.onDisplayUri);\n\n  _classPrivateFieldGet(this, _provider).removeListener(\"call_request_sent\", this.onRequestSent);\n}\n\nexport { WalletConnectV1Connector };","map":null,"metadata":{},"sourceType":"module"}