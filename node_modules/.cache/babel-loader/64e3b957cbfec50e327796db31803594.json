{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-9d546189.browser.esm.js';\nimport { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { AbstractWallet } from '../evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport { defaultChains } from '@thirdweb-dev/chains';\nconst PREFIX = \"__TW__\";\n\nclass AsyncLocalStorage {\n  constructor(name) {\n    _defineProperty(this, \"name\", void 0);\n\n    this.name = name;\n  }\n\n  getItem(key) {\n    return new Promise(res => {\n      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));\n    });\n  }\n\n  setItem(key, value) {\n    return new Promise((res, rej) => {\n      try {\n        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);\n        res();\n      } catch (e) {\n        rej(e);\n      }\n    });\n  }\n\n  removeItem(key) {\n    return new Promise(res => {\n      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);\n      res();\n    });\n  }\n\n}\n\nfunction createAsyncLocalStorage(name) {\n  return new AsyncLocalStorage(name);\n}\n\nconst DEFAULT_DAPP_META = {\n  name: \"thirdweb powered dApp\",\n  url: \"https://thirdweb.com\",\n  description: \"thirdweb powered dApp\",\n  logoUrl: \"https://thirdweb.com/favicon.ico\",\n  isDarkMode: true\n};\n\nvar _connect = /*#__PURE__*/new WeakSet();\n\nvar _subscribeToEvents = /*#__PURE__*/new WeakSet();\n\nclass AbstractBrowserWallet extends AbstractWallet {\n  getMeta() {\n    return this.constructor.meta;\n  }\n\n  constructor(walletId, options) {\n    super();\n\n    _classPrivateMethodInitSpec(this, _subscribeToEvents);\n\n    _classPrivateMethodInitSpec(this, _connect);\n\n    _defineProperty(this, \"walletId\", void 0);\n\n    _defineProperty(this, \"walletStorage\", void 0);\n\n    _defineProperty(this, \"chains\", void 0);\n\n    _defineProperty(this, \"dappMetadata\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    this.walletId = walletId;\n    this.options = options;\n    this.chains = options?.chains || defaultChains;\n    this.dappMetadata = options?.dappMetadata || DEFAULT_DAPP_META;\n    this.walletStorage = options?.walletStorage || createAsyncLocalStorage(this.walletId);\n  }\n  /**\n   * tries to auto connect to the wallet\n   */\n\n\n  async autoConnect(connectOptions) {\n    // remove chainId when autoconnecting to prevent switch-network popup on page load\n    const options = connectOptions ? { ...connectOptions,\n      chainId: undefined\n    } : undefined;\n    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);\n  }\n  /**\n   * connect to the wallet\n   */\n\n\n  async connect(connectOptions) {\n    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);\n\n    if (!address) {\n      throw new Error(\"Failed to connect to the wallet.\");\n    }\n\n    return address;\n  }\n\n  async getSigner() {\n    const connector = await this.getConnector();\n\n    if (!connector) {\n      throw new Error(\"Wallet not connected\");\n    }\n\n    return await connector.getSigner();\n  }\n\n  async disconnect() {\n    const connector = await this.getConnector();\n\n    if (connector) {\n      await connector.disconnect();\n      this.emit(\"disconnect\");\n      connector.removeAllListeners();\n    }\n  }\n\n  async switchChain(chainId) {\n    const connector = await this.getConnector();\n\n    if (!connector) {\n      throw new Error(\"Wallet not connected\");\n    }\n\n    if (!connector.switchChain) {\n      throw new Error(\"Wallet does not support switching chains\");\n    }\n\n    return await connector.switchChain(chainId);\n  }\n\n  async updateChains(chains) {\n    this.chains = chains;\n    const connector = await this.getConnector();\n    connector.updateChains(chains);\n  }\n\n}\n\nasync function _connect2(isAutoConnect, connectOptions) {\n  const connector = await this.getConnector();\n\n  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);\n\n  const isConnected = await connector.isConnected(); // if already connected, return the address and setup listeners\n\n  if (isConnected) {\n    const address = await connector.getAddress();\n    connector.setupListeners(); // ensure that connector is connected to the correct chain\n\n    if (connectOptions?.chainId) {\n      await connector.switchChain(connectOptions?.chainId);\n    }\n\n    this.emit(\"connect\", {\n      address,\n      chainId: await this.getChainId()\n    });\n    return address;\n  }\n\n  if (isAutoConnect) {\n    throw new Error(\"Failed to auto connect to the wallet.\");\n  }\n\n  const address = await connector.connect(connectOptions);\n  return address;\n}\n\nasync function _subscribeToEvents2(connector) {\n  // subscribe to connector for events\n  connector.on(\"connect\", data => {\n    this.emit(\"connect\", {\n      address: data.account,\n      chainId: data.chain?.id\n    });\n  });\n  connector.on(\"change\", data => {\n    this.emit(\"change\", {\n      address: data.account,\n      chainId: data.chain?.id\n    });\n  });\n  connector.on(\"message\", data => {\n    this.emit(\"message\", data);\n  });\n  connector.on(\"disconnect\", async () => {\n    this.emit(\"disconnect\");\n  });\n  connector.on(\"error\", error => this.emit(\"error\", error));\n}\n\n_defineProperty(AbstractBrowserWallet, \"meta\", void 0);\n\nexport { AsyncLocalStorage as A, DEFAULT_DAPP_META as D, AbstractBrowserWallet as a, createAsyncLocalStorage as c };","map":null,"metadata":{},"sourceType":"module"}