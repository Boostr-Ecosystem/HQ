{"ast":null,"code":"import { _ as _classPrivateFieldInitSpec, b as _classPrivateFieldGet, a as _classPrivateFieldSet } from '../../../../dist/classPrivateFieldSet-eea39a9a.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { T as TWConnector } from '../../../../dist/tw-connector-443c384d.browser.esm.js';\nimport { UserStatus } from '@paperxyz/embedded-wallet-service-sdk';\nimport { utils } from 'ethers';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport '../../../../dist/checkPrivateRedeclaration-3aaaa21d.browser.esm.js';\nimport 'eventemitter3';\nconst PaperChainMap = {\n  1: \"Ethereum\",\n  5: \"Goerli\",\n  137: \"Polygon\",\n  80001: \"Mumbai\"\n};\n\nvar _paper = /*#__PURE__*/new WeakMap();\n\nvar _signer = /*#__PURE__*/new WeakMap();\n\nclass PaperWalletConnector extends TWConnector {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"id\", \"paper-wallet\");\n\n    _defineProperty(this, \"name\", \"Paper Wallet\");\n\n    _defineProperty(this, \"ready\", true);\n\n    _defineProperty(this, \"user\", null);\n\n    _classPrivateFieldInitSpec(this, _paper, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"options\", void 0);\n\n    _classPrivateFieldInitSpec(this, _signer, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", async accounts => {\n      if (accounts.length === 0) {\n        await this.onDisconnect();\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", async () => {\n      this.emit(\"disconnect\");\n    });\n\n    this.options = options;\n  }\n\n  getPaperSDK() {\n    if (!_classPrivateFieldGet(this, _paper)) {\n      _classPrivateFieldSet(this, _paper, new Promise(async (resolve, reject) => {\n        try {\n          if (!(this.options.chain.chainId in PaperChainMap)) {\n            throw new Error(\"Unsupported chain id: \" + this.options.chain.chainId);\n          }\n\n          const {\n            PaperEmbeddedWalletSdk\n          } = await import('@paperxyz/embedded-wallet-service-sdk');\n          const chainName = PaperChainMap[this.options.chain.chainId];\n          resolve(new PaperEmbeddedWalletSdk({\n            clientId: this.options.clientId,\n            chain: chainName\n          }));\n        } catch (err) {\n          reject(err);\n        }\n      }));\n    }\n\n    return _classPrivateFieldGet(this, _paper);\n  }\n\n  async connect() {\n    const paperSDK = await this.getPaperSDK();\n\n    if (!paperSDK) {\n      throw new Error(\"Paper SDK not initialized\");\n    }\n\n    let user = await paperSDK.getUser();\n\n    switch (user.status) {\n      case UserStatus.LOGGED_OUT:\n        {\n          const authResult = await paperSDK.auth.loginWithPaperModal();\n          this.user = authResult.user;\n          break;\n        }\n\n      case UserStatus.LOGGED_IN_WALLET_INITIALIZED:\n        {\n          this.user = user;\n          break;\n        }\n    }\n\n    if (!this.user) {\n      throw new Error(\"Error connecting User\");\n    }\n\n    this.setupListeners();\n    return this.getAddress();\n  }\n\n  async disconnect() {\n    // await this.paper?.auth.logout();\n    this.user = null;\n  }\n\n  async getAddress() {\n    const signer = await this.getSigner();\n    return signer.getAddress();\n  }\n\n  async isConnected() {\n    try {\n      const addr = await this.getAddress();\n      return !!addr;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  async getProvider() {\n    const signer = await this.getSigner();\n\n    if (!signer.provider) {\n      throw new Error(\"Provider not found\");\n    }\n\n    return signer.provider;\n  }\n\n  async getSigner() {\n    if (_classPrivateFieldGet(this, _signer)) {\n      return _classPrivateFieldGet(this, _signer);\n    }\n\n    if (!this.user) {\n      const paperSDK = await this.getPaperSDK();\n      let user = await paperSDK.getUser();\n\n      switch (user.status) {\n        case UserStatus.LOGGED_IN_WALLET_INITIALIZED:\n          {\n            this.user = user;\n            break;\n          }\n      }\n    }\n\n    const signer = await this.user?.wallet.getEthersJsSigner({\n      rpcEndpoint: this.options.chain.rpc[0]\n    });\n\n    if (!signer) {\n      throw new Error(\"Signer not found\");\n    }\n\n    _classPrivateFieldSet(this, _signer, signer);\n\n    return signer;\n  }\n\n  async isAuthorized() {\n    return false;\n  }\n\n  async switchChain(chainId) {\n    // check if chainId is supported or not\n    if (!(chainId in PaperChainMap)) {\n      throw new Error(\"Chain not supported\");\n    }\n\n    const chainName = PaperChainMap[chainId];\n    const chain = this.options.chains.find(c => c.chainId === chainId);\n\n    if (!chain) {\n      throw new Error(\"Chain not configured\");\n    } // update chain in wallet\n\n\n    await this.user?.wallet.setChain({\n      chain: chainName\n    }); // update signer\n\n    _classPrivateFieldSet(this, _signer, await this.user?.wallet.getEthersJsSigner({\n      rpcEndpoint: chain.rpc[0]\n    }));\n\n    this.emit(\"change\", {\n      chain: {\n        id: chainId,\n        unsupported: false\n      }\n    });\n  } // private getUser() {\n  //   if (!this.user) {\n  //     throw new Error(\"User not found\");\n  //   }\n  //   return this.user;\n  // }\n\n\n  async setupListeners() {\n    const provider = await this.getProvider();\n\n    if (provider.on) {\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n    }\n  }\n\n  updateChains(chains) {\n    this.options.chains = chains;\n  }\n\n  isChainUnsupported(chainId) {\n    return !(chainId in PaperChainMap);\n  }\n\n  async getEmail() {\n    await this.getProvider();\n\n    if (!this.user) {\n      throw new Error(\"No user found, Paper Wallet is not connected\");\n    }\n\n    return this.user.authDetails.email;\n  }\n\n}\n\nexport { PaperChainMap, PaperWalletConnector };","map":null,"metadata":{},"sourceType":"module"}