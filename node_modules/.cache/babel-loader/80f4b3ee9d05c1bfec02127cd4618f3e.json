{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"../../utils\");\n\nclass GnosisSafeContractEthers {\n  constructor(contract) {\n    this.contract = contract;\n\n    this.encode = (methodName, params) => {\n      return this.contract.interface.encodeFunctionData(methodName, params);\n    };\n  }\n\n  async getVersion() {\n    return await this.contract.VERSION();\n  }\n\n  getAddress() {\n    return this.contract.address;\n  }\n\n  async getNonce() {\n    return (await this.contract.nonce()).toNumber();\n  }\n\n  async getThreshold() {\n    return (await this.contract.getThreshold()).toNumber();\n  }\n\n  async getOwners() {\n    return this.contract.getOwners();\n  }\n\n  async isOwner(address) {\n    return this.contract.isOwner(address);\n  }\n\n  async getTransactionHash(safeTransactionData) {\n    return this.contract.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce);\n  }\n\n  async approvedHashes(ownerAddress, hash) {\n    return this.contract.approvedHashes(ownerAddress, hash);\n  }\n\n  async approveHash(hash, options) {\n    if (options && !options.gasLimit) {\n      options.gasLimit = await this.estimateGas('approveHash', [hash], { ...options\n      });\n    }\n\n    const txResponse = await this.contract.approveHash(hash, options);\n    return (0, utils_1.toTxResult)(txResponse, options);\n  }\n\n  async isValidTransaction(safeTransaction, options) {\n    let isTxValid = false;\n\n    try {\n      if (options && !options.gasLimit) {\n        options.gasLimit = await this.estimateGas('execTransaction', [safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures()], { ...options\n        });\n      }\n\n      isTxValid = await this.contract.callStatic.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);\n    } catch {}\n\n    return isTxValid;\n  }\n\n  async execTransaction(safeTransaction, options) {\n    if (options && !options.gasLimit) {\n      options.gasLimit = await this.estimateGas('execTransaction', [safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures()], { ...options\n      });\n    }\n\n    const txResponse = await this.contract.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);\n    return (0, utils_1.toTxResult)(txResponse, options);\n  }\n\n  async estimateGas(methodName, params, options) {\n    return (await this.contract.estimateGas[methodName](...params, options)).toNumber();\n  }\n\n}\n\nexports.default = GnosisSafeContractEthers; //# sourceMappingURL=GnosisSafeContractEthers.js.map","map":null,"metadata":{},"sourceType":"script"}