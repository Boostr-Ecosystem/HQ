{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Base = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\n\nclass Base {\n  /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */\n  print() {\n    Base.print(this);\n  }\n  /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */\n\n\n  _bufferIndexOf(array, element) {\n    for (let i = 0; i < array.length; i++) {\n      if (element.equals(array[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */\n\n\n  static bufferify(value) {\n    if (!buffer_1.Buffer.isBuffer(value)) {\n      // crypto-js support\n      if (typeof value === 'object' && value.words) {\n        return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n      } else if (Base.isHexString(value)) {\n        return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n      } else if (typeof value === 'string') {\n        return buffer_1.Buffer.from(value);\n      } else if (typeof value === 'number') {\n        let s = value.toString();\n\n        if (s.length % 2) {\n          s = `0${s}`;\n        }\n\n        return buffer_1.Buffer.from(s, 'hex');\n      } else if (ArrayBuffer.isView(value)) {\n        return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n      }\n    }\n\n    return value;\n  }\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n\n\n  static isHexString(v) {\n    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n  /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */\n\n\n  static print(tree) {\n    console.log(tree.toString());\n  }\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n\n\n  bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Base.bufferToHex(value, withPrefix);\n  }\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n\n\n  static bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n  }\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */\n\n\n  bufferify(value) {\n    return Base.bufferify(value);\n  }\n  /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */\n\n\n  bufferifyFn(f) {\n    return value => {\n      const v = f(value);\n\n      if (buffer_1.Buffer.isBuffer(v)) {\n        return v;\n      }\n\n      if (this._isHexString(v)) {\n        return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n      }\n\n      if (typeof v === 'string') {\n        return buffer_1.Buffer.from(v);\n      }\n\n      if (ArrayBuffer.isView(v)) {\n        return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n      } // crypto-js support\n\n\n      return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n    };\n  }\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n\n\n  _isHexString(value) {\n    return Base.isHexString(value);\n  }\n  /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */\n\n\n  _log2(n) {\n    return n === 1 ? 0 : 1 + this._log2(n / 2 | 0);\n  }\n  /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */\n\n\n  _zip(a, b) {\n    return a.map((e, i) => [e, b[i]]);\n  }\n\n}\n\nexports.Base = Base;\nexports.default = Base;","map":null,"metadata":{},"sourceType":"script"}