{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\n\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nconst treeify_1 = __importDefault(require(\"treeify\"));\n\nconst Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\n\n\nclass MerkleTree extends Base_1.default {\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves) {\n    let hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.duplicateOdd = false;\n    this.hashLeaves = false;\n    this.isBitcoinTree = false;\n    this.leaves = [];\n    this.layers = [];\n    this.sortLeaves = false;\n    this.sortPairs = false;\n    this.sort = false;\n    this.fillDefaultHash = null;\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n\n    this.sort = !!options.sort;\n\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n\n    this.duplicateOdd = !!options.duplicateOdd;\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.processLeaves(leaves);\n  }\n\n  processLeaves(leaves) {\n    if (this.hashLeaves) {\n      leaves = leaves.map(this.hashFn);\n    }\n\n    this.leaves = leaves.map(this.bufferify);\n\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n    }\n\n    if (this.fillDefaultHash) {\n      for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        if (i >= this.leaves.length) {\n          this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n        }\n      }\n    }\n\n    this.layers = [this.leaves];\n\n    this._createHashes(this.leaves);\n  }\n\n  _createHashes(nodes) {\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            let data = nodes[nodes.length - 1];\n            let hash = data; // is bitcoin tree\n\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              data = buffer_1.Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n              hash = this.hashFn(data);\n              hash = buffer_reverse_1.default(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) {// continue with creating layer\n              } else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let data = null;\n        let combined = null;\n\n        if (this.isBitcoinTree) {\n          combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n        } else {\n          combined = [left, right];\n        }\n\n        if (this.sortPairs) {\n          combined.sort(buffer_1.Buffer.compare);\n        }\n\n        data = buffer_1.Buffer.concat(combined);\n        let hash = this.hashFn(data); // double hash if bitcoin tree\n\n        if (this.isBitcoinTree) {\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        }\n\n        this.layers[layerIndex].push(hash);\n      }\n\n      nodes = this.layers[layerIndex];\n    }\n  }\n  /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */\n\n\n  addLeaf(leaf) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (shouldHash) {\n      leaf = this.hashFn(leaf);\n    }\n\n    this.processLeaves(this.leaves.concat(leaf));\n  }\n  /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */\n\n\n  addLeaves(leaves) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (shouldHash) {\n      leaves = leaves.map(this.hashFn);\n    }\n\n    this.processLeaves(this.leaves.concat(leaves));\n  }\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n\n\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(this.hashFn);\n\n        if (this.sortLeaves) {\n          values = values.sort(buffer_1.Buffer.compare);\n        }\n      }\n\n      return this.leaves.filter(leaf => this._bufferIndexOf(values, leaf) !== -1);\n    }\n\n    return this.leaves;\n  }\n  /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */\n\n\n  getLeaf(index) {\n    if (index < 0 || index > this.leaves.length - 1) {\n      return buffer_1.Buffer.from([]);\n    }\n\n    return this.leaves[index];\n  }\n  /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */\n\n\n  getLeafIndex(target) {\n    target = this.bufferify(target);\n    const leaves = this.getLeaves();\n\n    for (let i = 0; i < leaves.length; i++) {\n      const leaf = leaves[i];\n\n      if (leaf.equals(target)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */\n\n\n  getLeafCount() {\n    return this.leaves.length;\n  }\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n\n\n  getHexLeaves() {\n    return this.leaves.map(leaf => this.bufferToHex(leaf));\n  }\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n\n\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n  }\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n\n\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n\n    if (!parsed) {\n      return [];\n    }\n\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n\n    return parsed.map(MerkleTree.bufferify);\n  }\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n\n\n  getLayers() {\n    return this.layers;\n  }\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n\n\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(layer)));\n      } else {\n        acc.push(item);\n      }\n\n      return acc;\n    }, []);\n  }\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n\n\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n\n      return acc;\n    }, []);\n    layers.unshift(buffer_1.Buffer.from([0]));\n    return layers;\n  }\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n\n\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n  }\n  /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */\n\n\n  getLayerCount() {\n    return this.getLayers().length;\n  }\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n\n\n  getRoot() {\n    if (this.layers.length === 0) {\n      return buffer_1.Buffer.from([]);\n    }\n\n    return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n  }\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n\n\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n\n\n  getProof(leaf, index) {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required');\n    }\n\n    leaf = this.bufferify(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 // Proof Generation for Bitcoin Trees\n      ? index // Proof Generation for Non-Bitcoin Trees\n      : index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      } // set index to parent index\n\n\n      index = index / 2 | 0;\n    }\n\n    return proof;\n  }\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n\n\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n  }\n  /**\n  * getPositionalHexProof\n  * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n  * @param {Buffer} leaf - Target leaf\n  * @param {Number} [index] - Target leaf index in leaves array.\n  * Use if there are leaves containing duplicate data in order to distinguish it.\n  * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n  * @example\n  * ```js\n  *const proof = tree.getPositionalHexProof(leaves[2])\n  *```\n  */\n\n\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => {\n      return [item.position === 'left' ? 0 : 1, this.bufferToHex(item.data)];\n    });\n  }\n  /**\n   * marshalProof\n   * @desc Returns proof array as JSON string.\n   * @param {String[]|Object[]} proof - Merkle tree proof array\n   * @return {String} - Proof array as JSON string.\n   * @example\n   * ```js\n   *const jsonStr = MerkleTree.marshalProof(proof)\n   *```\n   */\n\n\n  static marshalProof(proof) {\n    const json = proof.map(item => {\n      if (typeof item === 'string') {\n        return item;\n      }\n\n      if (buffer_1.Buffer.isBuffer(item)) {\n        return MerkleTree.bufferToHex(item);\n      }\n\n      return {\n        position: item.position,\n        data: MerkleTree.bufferToHex(item.data)\n      };\n    });\n    return JSON.stringify(json, null, 2);\n  }\n  /**\n   * unmarshalProof\n   * @desc Returns the proof for a target leaf as a list of Buffers.\n   * @param {String|Object} - Merkle tree leaves\n   * @return {String|Object} - Marshalled proof\n   * @example\n   * ```js\n   *const proof = MerkleTree.unmarshalProof(jsonStr)\n   *```\n   */\n\n\n  static unmarshalProof(jsonStr) {\n    let parsed = null;\n\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n\n    if (!parsed) {\n      return [];\n    }\n\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n\n    return parsed.map(item => {\n      if (typeof item === 'string') {\n        return MerkleTree.bufferify(item);\n      } else if (item instanceof Object) {\n        return {\n          position: item.position,\n          data: MerkleTree.bufferify(item.data)\n        };\n      } else {\n        throw new Error('Expected item to be of type string or object');\n      }\n    });\n  }\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n\n\n  getProofIndices(treeIndices, depth) {\n    const leafCount = Math.pow(2, depth);\n    let maximalIndices = new Set();\n\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) break;\n          index = index / 2 | 0;\n        }\n      }\n    }\n\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n\n  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n    const depth = Math.ceil(Math.log2(leavesCount));\n    const unevenLayers = [];\n\n    for (let index = 0; index < depth; index++) {\n      const unevenLayer = leavesCount % 2 !== 0;\n\n      if (unevenLayer) {\n        unevenLayers.push({\n          index,\n          leavesCount\n        });\n      }\n\n      leavesCount = Math.ceil(leavesCount / 2);\n    }\n\n    const proofIndices = [];\n    let layerNodes = sortedLeafIndices;\n\n    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n      const siblingIndices = layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index + 1;\n        }\n\n        return index - 1;\n      });\n      let proofNodeIndices = siblingIndices.filter(index => !layerNodes.includes(index));\n      const unevenLayer = unevenLayers.find(_ref => {\n        let {\n          index\n        } = _ref;\n        return index === layerIndex;\n      });\n\n      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n        proofNodeIndices = proofNodeIndices.slice(0, -1);\n      }\n\n      proofIndices.push(proofNodeIndices);\n      layerNodes = [...new Set(layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n\n        return (index - 1) / 2;\n      }))];\n    }\n\n    return proofIndices;\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n\n\n  getMultiProof(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n    }\n\n    const isUneven = this.isUnevenTree();\n\n    if (isUneven) {\n      if (indices.every(Number.isInteger)) {\n        return this.getMultiProofForUnevenTree(indices);\n      }\n    }\n\n    if (!indices.every(Number.isInteger)) {\n      let els = indices;\n\n      if (this.sortPairs) {\n        els = els.sort(buffer_1.Buffer.compare);\n      }\n\n      let ids = els.map(el => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n\n      if (!ids.every(idx => idx !== -1)) {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n\n      const hashes = [];\n      const proof = [];\n      let nextIds = [];\n\n      for (let i = 0; i < this.layers.length; i++) {\n        const layer = this.layers[i];\n\n        for (let j = 0; j < ids.length; j++) {\n          const idx = ids[j];\n\n          const pairElement = this._getPairNode(layer, idx);\n\n          hashes.push(layer[idx]);\n\n          if (pairElement) {\n            proof.push(pairElement);\n          }\n\n          nextIds.push(idx / 2 | 0);\n        }\n\n        ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n        nextIds = [];\n      }\n\n      return proof.filter(value => !hashes.includes(value));\n    }\n\n    return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map(index => tree[index]);\n  }\n\n  getMultiProofForUnevenTree(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayers();\n    }\n\n    let proofHashes = [];\n    let currentLayerIndices = indices;\n\n    for (const treeLayer of tree) {\n      const siblings = [];\n\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          const idx = index + 1;\n\n          if (!currentLayerIndices.includes(idx)) {\n            if (treeLayer[idx]) {\n              siblings.push(treeLayer[idx]);\n              continue;\n            }\n          }\n        }\n\n        const idx = index - 1;\n\n        if (!currentLayerIndices.includes(idx)) {\n          if (treeLayer[idx]) {\n            siblings.push(treeLayer[idx]);\n            continue;\n          }\n        }\n      }\n\n      proofHashes = proofHashes.concat(siblings);\n      const uniqueIndices = new Set();\n\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          uniqueIndices.add(index / 2);\n          continue;\n        }\n\n        if (index % 2 === 0) {\n          uniqueIndices.add((index + 1) / 2);\n          continue;\n        }\n\n        uniqueIndices.add((index - 1) / 2);\n      }\n\n      currentLayerIndices = Array.from(uniqueIndices);\n    }\n\n    return proofHashes;\n  }\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n\n\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n\n\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error('Invalid Inputs!');\n    }\n\n    let ids;\n\n    if (leaves.every(Number.isInteger)) {\n      ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error('Element does not exist in Merkle tree');\n    }\n\n    const _proofs = proofs.map(item => this.bufferify(item));\n\n    const tested = [];\n    const flags = [];\n\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids, idx) => {\n        const skipped = tested.includes(layer[idx]);\n\n        if (!skipped) {\n          const pairElement = this._getPairNode(layer, idx);\n\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n\n        ids.push(idx / 2 | 0);\n        return ids;\n      }, []);\n    }\n\n    return flags;\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n\n\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null; // case for when proof is hex values only\n\n      if (typeof node === 'string') {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (buffer_1.Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === 'left';\n      } else {\n        throw new Error('Expected node to be of type string or object');\n      }\n\n      const buffers = [];\n\n      if (this.isBitcoinTree) {\n        buffers.push(buffer_reverse_1.default(hash));\n        buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n        hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n        hash = buffer_reverse_1.default(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (buffer_1.Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? 'unshift' : 'push'](data);\n          hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n        }\n      }\n    }\n\n    return buffer_1.Buffer.compare(hash, root) === 0;\n  }\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */\n\n\n  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n    const isUneven = this.isUnevenTree();\n\n    if (isUneven) {\n      // TODO: combine these functions and simplify\n      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n    }\n\n    const depth = Math.ceil(Math.log2(leavesCount));\n    root = this.bufferify(root);\n    proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const tree = {};\n\n    for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {\n      tree[Math.pow(2, depth) + index] = leaf;\n    }\n\n    for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {\n      tree[index] = proofitem;\n    }\n\n    let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n\n        if (this.sortPairs) {\n          pair = pair.sort(buffer_1.Buffer.compare);\n        }\n\n        const hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];\n        tree[index / 2 | 0] = hash;\n        indexqueue.push(index / 2 | 0);\n      }\n\n      i += 1;\n    }\n\n    return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n\n  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n    root = this.bufferify(root);\n    leaves = leaves.map(this.bufferify);\n    proofs = proofs.map(this.bufferify);\n    const leavesLen = leaves.length;\n    const totalHashes = proofFlag.length;\n    const hashes = [];\n    let leafPos = 0;\n    let hashPos = 0;\n    let proofPos = 0;\n\n    for (let i = 0; i < totalHashes; i++) {\n      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n      hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));\n    }\n\n    return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n  }\n\n  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n    return root.equals(computedRoot);\n  }\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n\n\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n\n\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n\n        if (objs.length) {\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          const akey = Object.keys(a)[0];\n          obj[layers[i][j]][akey] = a[akey];\n\n          if (objs.length) {\n            const b = objs.shift();\n            const bkey = Object.keys(b)[0];\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n\n        arr.push(obj);\n      }\n\n      objs.push(...arr);\n    }\n\n    return objs[0];\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @return {Boolean}\n   * @example\n   *```js\n   *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n   *```\n   */\n\n\n  static verify(proof, targetNode, root) {\n    let hashFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sha256_1.default;\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const tree = new MerkleTree([], hashFn, options);\n    return tree.verify(proof, targetNode, root);\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Buffer[]} tree - Tree as a flat array.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   *\n   *@example\n   * ```js\n   *const flatTree = tree.getLayersFlat()\n   *const indices = [2, 5, 6]\n   *const proof = MerkleTree.getMultiProof(flatTree, indices)\n   *```\n   */\n\n\n  static getMultiProof(tree, indices) {\n    const t = new MerkleTree([]);\n    return t.getMultiProof(tree, indices);\n  }\n  /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */\n\n\n  resetTree() {\n    this.leaves = [];\n    this.layers = [];\n  }\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n\n\n  _getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n\n\n  _toTreeString() {\n    const obj = this.getLayersAsObject();\n    return treeify_1.default.asTree(obj, true);\n  }\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n\n\n  toString() {\n    return this._toTreeString();\n  }\n\n  isUnevenTree(treeLayers) {\n    const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n    return !this.isPowOf2(depth);\n  }\n\n  isPowOf2(v) {\n    return v && !(v & v - 1);\n  }\n\n  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n    const leafTuples = this._zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {\n      let [indexA] = _ref2;\n      let [indexB] = _ref3;\n      return indexA - indexB;\n    });\n\n    const leafTupleIndices = leafTuples.map(_ref4 => {\n      let [index] = _ref4;\n      return index;\n    });\n    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n    let nextSliceStart = 0;\n    const proofTuplesByLayers = [];\n\n    for (let i = 0; i < proofIndices.length; i++) {\n      const indices = proofIndices[i];\n      const sliceStart = nextSliceStart;\n      nextSliceStart += indices.length;\n      proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n    }\n\n    const tree = [leafTuples];\n\n    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort((_ref5, _ref6) => {\n        let [indexA] = _ref5;\n        let [indexB] = _ref6;\n        return indexA - indexB;\n      }).map(_ref7 => {\n        let [, hash] = _ref7;\n        return hash;\n      });\n      const s = tree[layerIndex].map(_ref8 => {\n        let [layerIndex] = _ref8;\n        return layerIndex;\n      });\n      const parentIndices = [...new Set(s.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n\n        return (index - 1) / 2;\n      }))];\n      const parentLayer = [];\n\n      for (let i = 0; i < parentIndices.length; i++) {\n        const parentNodeTreeIndex = parentIndices[i];\n        const bufA = currentLayer[i * 2];\n        const bufB = currentLayer[i * 2 + 1];\n        const hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;\n        parentLayer.push([parentNodeTreeIndex, hash]);\n      }\n\n      tree.push(parentLayer);\n    }\n\n    return tree[tree.length - 1][0][1];\n  }\n\n}\n\nexports.MerkleTree = MerkleTree;\n\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\n\nexports.default = MerkleTree;","map":null,"metadata":{},"sourceType":"script"}