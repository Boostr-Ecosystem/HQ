{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n/**\n * Link represents an IPFS Merkle DAG Link between Nodes.\n */\n\n\nclass DAGLink {\n  /**\n   * @param {string | undefined | null} name\n   * @param {number} size\n   * @param {CID | string | Uint8Array} cid\n   */\n  constructor(name, size, cid) {\n    if (!cid) {\n      throw new Error('A link requires a cid to point to');\n    } // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n\n\n    this.Name = name || '';\n    this.Tsize = size;\n    this.Hash = new CID(cid);\n    Object.defineProperties(this, {\n      _nameBuf: {\n        value: null,\n        writable: true,\n        enumerable: false\n      }\n    });\n  }\n\n  toString() {\n    return `DAGLink <${this.Hash.toBaseEncodedString()} - name: \"${this.Name}\", size: ${this.Tsize}>`;\n  }\n\n  toJSON() {\n    if (!this._json) {\n      this._json = Object.freeze({\n        name: this.Name,\n        size: this.Tsize,\n        cid: this.Hash.toBaseEncodedString()\n      });\n    }\n\n    return Object.assign({}, this._json);\n  } // Memoize the Uint8Array representation of name\n  // We need this to sort the links, otherwise\n  // we will reallocate new Uint8Arrays every time\n\n\n  get nameAsBuffer() {\n    if (this._nameBuf != null) {\n      return this._nameBuf;\n    }\n\n    this._nameBuf = uint8ArrayFromString(this.Name);\n    return this._nameBuf;\n  }\n\n}\n\nmodule.exports = DAGLink;","map":null,"metadata":{},"sourceType":"script"}