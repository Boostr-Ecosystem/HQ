{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _ModuleManager_ethAdapter, _ModuleManager_safeContract;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"../utils\");\n\nconst constants_1 = require(\"../utils/constants\");\n\nclass ModuleManager {\n  constructor(ethAdapter, safeContract) {\n    _ModuleManager_ethAdapter.set(this, void 0);\n\n    _ModuleManager_safeContract.set(this, void 0);\n\n    __classPrivateFieldSet(this, _ModuleManager_ethAdapter, ethAdapter, \"f\");\n\n    __classPrivateFieldSet(this, _ModuleManager_safeContract, safeContract, \"f\");\n  }\n\n  validateModuleAddress(moduleAddress) {\n    const isValidAddress = __classPrivateFieldGet(this, _ModuleManager_ethAdapter, \"f\").isAddress(moduleAddress);\n\n    if (!isValidAddress || (0, utils_1.isRestrictedAddress)(moduleAddress)) {\n      throw new Error('Invalid module address provided');\n    }\n  }\n\n  validateModuleIsNotEnabled(moduleAddress, modules) {\n    const moduleIndex = modules.findIndex(module => (0, utils_1.sameString)(module, moduleAddress));\n    const isEnabled = moduleIndex >= 0;\n\n    if (isEnabled) {\n      throw new Error('Module provided is already enabled');\n    }\n  }\n\n  validateModuleIsEnabled(moduleAddress, modules) {\n    const moduleIndex = modules.findIndex(module => (0, utils_1.sameString)(module, moduleAddress));\n    const isEnabled = moduleIndex >= 0;\n\n    if (!isEnabled) {\n      throw new Error('Module provided is not enabled yet');\n    }\n\n    return moduleIndex;\n  }\n\n  async getModules() {\n    return __classPrivateFieldGet(this, _ModuleManager_safeContract, \"f\").getModules();\n  }\n\n  async isModuleEnabled(moduleAddress) {\n    return __classPrivateFieldGet(this, _ModuleManager_safeContract, \"f\").isModuleEnabled(moduleAddress);\n  }\n\n  async encodeEnableModuleData(moduleAddress) {\n    this.validateModuleAddress(moduleAddress);\n    const modules = await this.getModules();\n    this.validateModuleIsNotEnabled(moduleAddress, modules);\n    return __classPrivateFieldGet(this, _ModuleManager_safeContract, \"f\").encode('enableModule', [moduleAddress]);\n  }\n\n  async encodeDisableModuleData(moduleAddress) {\n    this.validateModuleAddress(moduleAddress);\n    const modules = await this.getModules();\n    const moduleIndex = this.validateModuleIsEnabled(moduleAddress, modules);\n    const prevModuleAddress = moduleIndex === 0 ? constants_1.SENTINEL_ADDRESS : modules[moduleIndex - 1];\n    return __classPrivateFieldGet(this, _ModuleManager_safeContract, \"f\").encode('disableModule', [prevModuleAddress, moduleAddress]);\n  }\n\n}\n\n_ModuleManager_ethAdapter = new WeakMap(), _ModuleManager_safeContract = new WeakMap();\nexports.default = ModuleManager; //# sourceMappingURL=moduleManager.js.map","map":null,"metadata":{},"sourceType":"script"}