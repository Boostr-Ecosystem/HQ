{"ast":null,"code":"import E from \"pino\";\nimport A, { PROPOSAL_EXPIRY_MESSAGE as $ } from \"@walletconnect/sign-client\";\nimport { getSdkError as f, isValidArray as y } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions as N } from \"@walletconnect/logger\";\nimport { JsonRpcProvider as h } from \"@walletconnect/jsonrpc-provider\";\nimport u, { HttpConnection as H } from \"@walletconnect/jsonrpc-http-connection\";\nimport O from \"events\";\nconst g = \"error\",\n      b = \"wss://relay.walletconnect.com\",\n      q = \"wc\",\n      _ = \"universal_provider\",\n      P = `${q}@${2}:${_}:`,\n      D = \"https://rpc.walletconnect.com/v1\",\n      o = {\n  DEFAULT_CHAIN_CHANGED: \"default_chain_changed\"\n};\n\nfunction a(i, t, e) {\n  let s;\n  const n = m(i);\n  return t.rpcMap && (s = t.rpcMap[n]), s || (s = `${D}?chainId=eip155:${n}&projectId=${e}`), s;\n}\n\nfunction m(i) {\n  return i.includes(\"eip155\") ? Number(i.split(\":\")[1]) : Number(i);\n}\n\nfunction S(i, t) {\n  if (!t.includes(i)) throw new Error(`Chain '${i}' not approved. Please use one of the following: ${t.toString()}`);\n}\n\nfunction R(i) {\n  return i.map(t => `${t.split(\":\")[0]}:${t.split(\":\")[1]}`);\n}\n\nconst p = (i, t) => {\n  const e = s => {\n    s.request !== t.request || s.topic !== t.topic || (i.events.removeListener(\"session_request_sent\", e), j());\n  };\n\n  i.on(\"session_request_sent\", e);\n};\n\nfunction j() {\n  if (typeof window < \"u\") try {\n    const i = window.localStorage.getItem(\"WALLETCONNECT_DEEPLINK_CHOICE\");\n\n    if (i) {\n      const t = JSON.parse(i);\n      window.open(t.href, \"_self\", \"noreferrer noopener\");\n    }\n  } catch (i) {\n    console.error(i);\n  }\n}\n\nclass L {\n  constructor(t) {\n    this.name = \"eip155\", this.namespace = t.namespace, this.client = t.client, this.events = t.events, this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());\n  }\n\n  async request(t) {\n    var e;\n\n    switch (t.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n\n      case \"eth_accounts\":\n        return this.getAccounts();\n\n      case \"wallet_switchEthereumChain\":\n        return this.handleSwitchChain(t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : \"0x0\"), null;\n\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain());\n    }\n\n    return this.namespace.methods.includes(t.request.method) ? (p(this.client, t), await this.client.request(t)) : this.getHttpProvider().request(t.request);\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  setDefaultChain(t, e) {\n    const s = m(t);\n\n    if (!this.httpProviders[s]) {\n      const n = e || a(`${this.name}:${s}`, this.namespace, this.client.core.projectId);\n      if (!n) throw new Error(`No RPC url provided for chainId: ${s}`);\n      this.setHttpProvider(s, n);\n    }\n\n    this.chainId = s, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${s}`);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  getDefaultChain() {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || a(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n    return typeof s > \"u\" ? void 0 : new h(new H(s));\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      const s = m(e);\n      t[s] = this.createHttpProvider(s);\n    }), t;\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  getHttpProvider() {\n    const t = this.chainId,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  handleSwitchChain(t) {\n    const e = parseInt(t, 16),\n          s = `${this.name}:${e}`;\n    S(s, this.namespace.chains), this.setDefaultChain(`${e}`);\n  }\n\n}\n\nclass U {\n  constructor(t) {\n    this.name = \"solana\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? (p(this.client, t), this.client.request(t)) : this.getHttpProvider().request(t.request);\n  }\n\n  setDefaultChain(t, e) {\n    if (!this.httpProviders[t]) {\n      const s = e || a(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.chainId = t, this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || a(t, this.namespace, this.client.core.projectId);\n    return typeof s > \"u\" ? void 0 : new h(new u(s));\n  }\n\n}\n\nclass k {\n  constructor(t) {\n    this.name = \"cosmos\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? (p(this.client, t), this.client.request(t)) : this.getHttpProvider().request(t.request);\n  }\n\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || a(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || a(t, this.namespace, this.client.core.projectId);\n    return typeof s > \"u\" ? void 0 : new h(new u(s));\n  }\n\n}\n\nclass T {\n  constructor(t) {\n    this.name = \"cip34\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n\n  requestAccounts() {\n    return this.getAccounts();\n  }\n\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? (p(this.client, t), this.client.request(t)) : this.getHttpProvider().request(t.request);\n  }\n\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || this.getCardanoRPCUrl(t);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n\n    this.events.emit(o.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      const s = this.getCardanoRPCUrl(e);\n      t[e] = this.createHttpProvider(e, s);\n    }), t;\n  }\n\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n          e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n\n  getCardanoRPCUrl(t) {\n    const e = this.namespace.rpcMap;\n    if (e) return e[t];\n  }\n\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n\n  createHttpProvider(t, e) {\n    const s = e || this.getCardanoRPCUrl(t);\n    return typeof s > \"u\" ? void 0 : new h(new u(s));\n  }\n\n}\n\nvar F = Object.defineProperty,\n    G = Object.defineProperties,\n    z = Object.getOwnPropertyDescriptors,\n    w = Object.getOwnPropertySymbols,\n    x = Object.prototype.hasOwnProperty,\n    J = Object.prototype.propertyIsEnumerable,\n    C = (i, t, e) => t in i ? F(i, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: e\n}) : i[t] = e,\n    d = (i, t) => {\n  for (var e in t || (t = {})) x.call(t, e) && C(i, e, t[e]);\n\n  if (w) for (var e of w(t)) J.call(t, e) && C(i, e, t[e]);\n  return i;\n},\n    v = (i, t) => G(i, z(t));\n\nclass l {\n  constructor(t) {\n    this.events = new O(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.providerOpts = t, this.logger = typeof t?.logger < \"u\" && typeof t?.logger != \"string\" ? t.logger : E(N({\n      level: t?.logger || g\n    }));\n  }\n\n  static async init(t) {\n    const e = new l(t);\n    return await e.initialize(), e;\n  }\n\n  async request(t, e) {\n    const [s, n] = this.validateChain(e);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(s).request({\n      request: d({}, t),\n      chainId: `${s}:${n}`,\n      topic: this.session.topic\n    });\n  }\n\n  sendAsync(t, e, s) {\n    this.request(t, s).then(n => e(null, n)).catch(n => e(n, void 0));\n  }\n\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    })), await this.requestAccounts();\n  }\n\n  async disconnect() {\n    var t;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (t = this.session) == null ? void 0 : t.topic,\n      reason: f(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n\n  async connect(t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);\n  }\n\n  on(t, e) {\n    this.events.on(t, e);\n  }\n\n  once(t, e) {\n    this.events.once(t, e);\n  }\n\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n\n  off(t, e) {\n    this.events.off(t, e);\n  }\n\n  get isWalletConnect() {\n    return !0;\n  }\n\n  async pair(t) {\n    this.shouldAbortPairingAttempt = !1;\n    let e = 0;\n\n    do {\n      if (this.shouldAbortPairingAttempt) throw new Error(\"Pairing aborted\");\n      if (e >= this.maxPairingAttempts) throw new Error(\"Max auto pairing attempts reached\");\n      const {\n        uri: s,\n        approval: n\n      } = await this.client.connect({\n        pairingTopic: t,\n        requiredNamespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties\n      });\n      s && (this.uri = s, this.events.emit(\"display_uri\", s)), await n().then(r => {\n        this.session = r;\n      }).catch(r => {\n        if (r.message !== $) throw r;\n        e++;\n      });\n    } while (!this.session);\n\n    return this.onConnect(), this.session;\n  }\n\n  setDefaultChain(t, e) {\n    try {\n      const [s, n] = this.validateChain(t);\n      this.getProvider(s).setDefaultChain(n, e);\n    } catch (s) {\n      if (!/Please call connect/.test(s.message)) throw s;\n    }\n  }\n\n  async cleanupPendingPairings() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const e = this.client.pairing.getAll();\n\n    if (y(e)) {\n      for (const s of e) t.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);\n\n      this.logger.info(`Inactive pairings cleared: ${e.length}`);\n    }\n  }\n\n  abortPairingAttempt() {\n    this.shouldAbortPairingAttempt = !0;\n  }\n\n  async checkStorage() {\n    if (this.namespaces = (await this.getFromStore(\"namespaces\")) || {}, this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {}, this.client.session.length) {\n      const t = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[t]), this.createProviders();\n    }\n  }\n\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();\n  }\n\n  async createClient() {\n    this.client = this.providerOpts.client || (await A.init({\n      logger: this.providerOpts.logger || g,\n      relayUrl: this.providerOpts.relayUrl || b,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      name: this.providerOpts.name\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    Object.keys(this.namespaces).forEach(t => {\n      var e, s, n;\n      const r = ((e = this.session) == null ? void 0 : e.namespaces[t].accounts) || [],\n            I = R(r),\n            c = v(d({}, Object.assign(this.namespaces[t], (n = (s = this.optionalNamespaces) == null ? void 0 : s[t]) != null ? n : {})), {\n        accounts: r,\n        chains: I\n      });\n\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new L({\n            client: this.client,\n            namespace: c,\n            events: this.events\n          });\n          break;\n\n        case \"solana\":\n          this.rpcProviders[t] = new U({\n            client: this.client,\n            namespace: c,\n            events: this.events\n          });\n          break;\n\n        case \"cosmos\":\n          this.rpcProviders[t] = new k({\n            client: this.client,\n            namespace: c,\n            events: this.events\n          });\n          break;\n\n        case \"polkadot\":\n          break;\n\n        case \"cip34\":\n          this.rpcProviders[t] = new T({\n            client: this.client,\n            namespace: c,\n            events: this.events\n          });\n          break;\n      }\n    });\n  }\n\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", t => {\n      this.events.emit(\"session_ping\", t);\n    }), this.client.on(\"session_event\", t => {\n      const {\n        params: e\n      } = t,\n            {\n        event: s\n      } = e;\n      s.name === \"accountsChanged\" ? this.events.emit(\"accountsChanged\", s.data) : s.name === \"chainChanged\" ? this.onChainChanged(e.chainId) : this.events.emit(s.name, s.data), this.events.emit(\"session_event\", t);\n    }), this.client.on(\"session_update\", _ref => {\n      let {\n        topic: t,\n        params: e\n      } = _ref;\n      var s;\n      const {\n        namespaces: n\n      } = e,\n            r = (s = this.client) == null ? void 0 : s.session.get(t);\n      this.session = v(d({}, r), {\n        namespaces: n\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: t,\n        params: e\n      });\n    }), this.client.on(\"session_delete\", async t => {\n      await this.cleanup(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", v(d({}, f(\"USER_DISCONNECTED\")), {\n        data: t.topic\n      }));\n    }), this.on(o.DEFAULT_CHAIN_CHANGED, t => {\n      this.onChainChanged(t, !0);\n    });\n  }\n\n  getProvider(t) {\n    if (!this.rpcProviders[t]) throw new Error(`Provider not found: ${t}`);\n    return this.rpcProviders[t];\n  }\n\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(t => {\n      var e;\n      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);\n    });\n  }\n\n  setNamespaces(t) {\n    const {\n      namespaces: e,\n      optionalNamespaces: s,\n      sessionProperties: n\n    } = t;\n    if (!e || !Object.keys(e).length) throw new Error(\"Namespaces must be not empty\");\n    this.namespaces = e, this.optionalNamespaces = s, this.sessionProperties = n, this.persist(\"namespaces\", e), this.persist(\"optionalNamespaces\", s);\n  }\n\n  validateChain(t) {\n    const [e, s] = t?.split(\":\") || [\"\", \"\"];\n    if (e && !Object.keys(this.namespaces).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);\n    if (e && s) return [e, s];\n    const n = Object.keys(this.namespaces)[0],\n          r = this.rpcProviders[n].getDefaultChain();\n    return [n, r];\n  }\n\n  async requestAccounts() {\n    const [t] = this.validateChain();\n    return await this.getProvider(t).requestAccounts();\n  }\n\n  onChainChanged(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    const [s, n] = this.validateChain(t);\n    e || this.getProvider(s).setDefaultChain(n), this.namespaces[s].defaultChain = n, this.persist(\"namespaces\", this.namespaces), this.events.emit(\"chainChanged\", n);\n  }\n\n  onConnect() {\n    this.createProviders(), this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n\n  async cleanup() {\n    this.session = void 0, await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n\n  persist(t, e) {\n    this.client.core.storage.setItem(`${P}/${t}`, e);\n  }\n\n  async getFromStore(t) {\n    return await this.client.core.storage.getItem(`${P}/${t}`);\n  }\n\n}\n\nconst M = l;\nexport { M as UniversalProvider, l as default }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}