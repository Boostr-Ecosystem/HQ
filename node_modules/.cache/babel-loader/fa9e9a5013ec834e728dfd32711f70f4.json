{"ast":null,"code":"'use strict';\n\nconst DirFlat = require('./dir-flat');\n\nconst flatToShard = require('./flat-to-shard');\n\nconst Dir = require('./dir');\n\nconst toPathComponents = require('./utils/to-path-components');\n/**\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('./types').BlockAPI} BlockAPI\n * @typedef {(source: AsyncIterable<InProgressImportResult>, block: BlockAPI, options: ImporterOptions) => AsyncIterable<ImportResult>} TreeBuilder\n */\n\n/**\n * @param {InProgressImportResult} elem\n * @param {Dir} tree\n * @param {ImporterOptions} options\n */\n\n\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n\n  return tree;\n}\n/**\n * @param {Dir | InProgressImportResult} tree\n * @param {BlockAPI} block\n */\n\n\nasync function* flushAndYield(tree, block) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n\n    return;\n  }\n\n  yield* tree.flush(block);\n}\n/**\n * @type {TreeBuilder}\n */\n\n\nasync function* treeBuilder(source, block, options) {\n  /** @type {Dir} */\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n\n    tree = await addToTree(entry, tree, options);\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\n\nmodule.exports = treeBuilder;","map":null,"metadata":{},"sourceType":"script"}