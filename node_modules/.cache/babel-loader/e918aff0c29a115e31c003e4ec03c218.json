{"ast":null,"code":"'use strict';\n\nconst batch = require('it-batch');\n/**\n * @typedef {import('cids')} CID\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('../../types').ImporterOptions} ImporterOptions\n * @typedef {import('../../types').InProgressImportResult} InProgressImportResult\n * @typedef {import('../../types').TrickleDagNode} TrickleDagNode\n * @typedef {import('../../types').Reducer} Reducer\n * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder\n */\n\n/**\n * @type {FileDAGBuilder}\n */\n\n\nmodule.exports = async function trickleStream(source, reduce, options) {\n  const root = new Root(options.layerRepeat);\n  let iteration = 0;\n  let maxDepth = 1;\n  /** @type {SubTree} */\n\n  let subTree = root;\n\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce));\n      }\n\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++;\n      }\n\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n      iteration++;\n    }\n\n    subTree.append(layer);\n  }\n\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce));\n  }\n\n  return root.reduce(reduce);\n};\n\nclass SubTree {\n  /**\n   * @param {number} maxDepth\n   * @param {number} layerRepeat\n   * @param {number} [iteration=0]\n   */\n  constructor(maxDepth, layerRepeat) {\n    let iteration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    /** @type {TrickleDagNode} */\n\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n\n  isFull() {\n    if (!this.root.data) {\n      return false;\n    }\n\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      // can descend\n      this._addNextNodeToParent(this.node);\n\n      return false;\n    } // try to find new node from node.parent\n\n\n    const distantRelative = this._findParent(this.node, this.currentDepth);\n\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative);\n\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @param {TrickleDagNode} parent\n   */\n\n\n  _addNextNodeToParent(parent) {\n    this.parent = parent; // find site for new node\n\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    }; // @ts-ignore\n\n    parent.children.push(nextNode);\n    this.currentDepth = nextNode.depth;\n    this.node = nextNode;\n  }\n  /**\n   *\n   * @param {InProgressImportResult[]} layer\n   */\n\n\n  append(layer) {\n    this.node.data = layer;\n  }\n  /**\n   * @param {Reducer} reduce\n   */\n\n\n  reduce(reduce) {\n    return this._reduce(this.root, reduce);\n  }\n  /**\n   * @param {TrickleDagNode} node\n   * @param {Reducer} reduce\n   * @returns {Promise<InProgressImportResult>}\n   */\n\n\n  async _reduce(node, reduce) {\n    /** @type {InProgressImportResult[]} */\n    let children = [];\n\n    if (node.children.length) {\n      children = await Promise.all(node.children // @ts-ignore\n      .filter(child => child.data) // @ts-ignore\n      .map(child => this._reduce(child, reduce)));\n    }\n\n    return reduce((node.data || []).concat(children));\n  }\n  /**\n   * @param {TrickleDagNode} node\n   * @param {number} depth\n   * @returns {TrickleDagNode | undefined}\n   */\n\n\n  _findParent(node, depth) {\n    const parent = node.parent;\n\n    if (!parent || parent.depth === 0) {\n      return;\n    }\n\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      // this layer is full, may be able to traverse to a different branch\n      return this._findParent(parent, depth);\n    }\n\n    return parent;\n  }\n\n}\n\nclass Root extends SubTree {\n  /**\n   * @param {number} layerRepeat\n   */\n  constructor(layerRepeat) {\n    super(0, layerRepeat);\n    this.root.depth = 0;\n    this.currentDepth = 1;\n  }\n  /**\n   * @param {InProgressImportResult} child\n   */\n\n\n  addChild(child) {\n    this.root.children.push(child);\n  }\n  /**\n   * @param {Reducer} reduce\n   */\n\n\n  reduce(reduce) {\n    return reduce((this.root.data || []).concat(this.root.children));\n  }\n\n}","map":null,"metadata":{},"sourceType":"script"}